<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统原理学习笔记 | RainyDoor</title><meta name="author" content="RainyDoor,3391182076@qq.com"><meta name="copyright" content="RainyDoor"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 操作系统概述 1.1 操作系统的概念、功能和特征  操作系统的概念：操作系统（Operating System，OS）控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。 操作系统的功能和目标：  提供功能：  处理机管理 存储器管理 文件管理 设备管理   目标：安全、高效 向上层提">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统原理学习笔记">
<meta property="og:url" content="https://rainydoor.github.io/71959014.html">
<meta property="og:site_name" content="RainyDoor">
<meta property="og:description" content="第一章 操作系统概述 1.1 操作系统的概念、功能和特征  操作系统的概念：操作系统（Operating System，OS）控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。 操作系统的功能和目标：  提供功能：  处理机管理 存储器管理 文件管理 设备管理   目标：安全、高效 向上层提">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rainydoor.github.io/img/109310857_p0.png">
<meta property="article:published_time" content="2024-08-01T13:40:34.000Z">
<meta property="article:modified_time" content="2024-11-23T08:58:37.324Z">
<meta property="article:author" content="RainyDoor">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rainydoor.github.io/img/109310857_p0.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://rainydoor.github.io/71959014.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: RainyDoor","link":"链接: ","source":"来源: RainyDoor","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统原理学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-23 16:58:37'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/109310857_p0.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/114784301_p0.png')"><nav id="nav"><span id="blog-info"><a href="/" title="RainyDoor"><span class="site-name">RainyDoor</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统原理学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-01T13:40:34.000Z" title="发表于 2024-08-01 21:40:34">2024-08-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-23T08:58:37.324Z" title="更新于 2024-11-23 16:58:37">2024-11-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">30.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>89分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统原理学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章-操作系统概述">第一章 操作系统概述</h1>
<h2 id="1-1-操作系统的概念-功能和特征">1.1 操作系统的概念、功能和特征</h2>
<ol>
<li>操作系统的概念：<strong>操作系统</strong>（Operating System，OS）控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件</strong>资源，并合理地组织调度计算机的工作和资源的分配，以<strong>提供给用户和其他软件方便的接口和环境</strong>；它是计算机系统中最基本的<strong>系统软件</strong>。</li>
<li>操作系统的功能和目标：
<ul>
<li>提供功能：
<ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
</li>
<li>目标：安全、高效</li>
<li>向上层提供方便易用的服务
<ul>
<li>封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。</li>
<li>GUI 图形化用户接口（Graphical User Interface）：用户可以使用形象的图形化界面进行操作，而不再需要记忆复杂的命令、参数。</li>
<li>命令接口：
<ul>
<li>联机命令接口：交互式命令接口
<ul>
<li>特点：用户说一句，系统跟着做一句</li>
</ul>
</li>
<li>脱机命令接口：批处理命令接口
<ul>
<li>特点：用户说一堆，系统跟着做一堆</li>
</ul>
</li>
</ul>
</li>
<li>程序接口：可以在程序中进行<strong>系统调用</strong>来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码<strong>间接</strong>使用。</li>
</ul>
</li>
<li>需要实现<strong>对硬件机器的拓展</strong>
<ul>
<li>没有任何软件支持的计算机称为<strong>裸机</strong>。在裸机上安装的操作系统可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。</li>
<li>通常把覆盖了软件的机器称为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong>。</li>
<li>操作系统将 CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能相互协调配合，实现更多更复杂的功能。</li>
</ul>
</li>
</ul>
</li>
<li>特征
<ol>
<li>并发
<ul>
<li>定义：指两个或多个事件在<strong>同一时间间隔</strong>内发生。这些事件<strong>宏观上是同时发生</strong>的，但<strong>微观上是交替发生</strong>的。</li>
<li>并行：指两个或多个事件在<strong>同一时刻</strong>同时发生。</li>
<li>单核 CPU 同一时刻只能执行<strong>一个程序</strong>，各个程序只能<strong>并发</strong>地执行。</li>
<li>多核 CPU 同一时刻可以同时执行<strong>多个程序</strong>，多个程序可以<strong>并行</strong>地执行</li>
</ul>
</li>
<li>共享
<ul>
<li>定义：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</li>
<li>资源共享方式：
<ol>
<li>互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong>。</li>
<li>同时共享方式：系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong>。
<ul>
<li>注：所谓“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（分时共享）。</li>
</ul>
</li>
</ol>
</li>
<li>并发性和共享性的关系：以 QQ 和微信为例，如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义；如果失去共享性，则 QQ 和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发。因此，并发性和共享性是<strong>互为存在条件</strong>的。</li>
</ul>
</li>
<li>虚拟
<ul>
<li>定义：虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上对应物是用户感受到的。</li>
<li>空分复用技术：如虚拟存储器技术</li>
<li>时分复用技术 ：如虚拟处理器</li>
<li>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong>。</li>
</ul>
</li>
<li>异步
<ul>
<li>定义：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</li>
<li>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。<strong>只有系统拥有并发性，才有可能导致异步性</strong>。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="1-2-操作系统的发展和分类">1.2 操作系统的发展和分类</h2>
<ol>
<li>手工操作阶段
<ul>
<li>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低。</li>
</ul>
</li>
<li>单道批处理系统
<ul>
<li>通过外围机把程序提前存到磁带里，引入<strong>脱机输入/输出技术</strong>，并由<strong>监督程序</strong>负责控制作业的输入、输出。</li>
<li>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</li>
<li>主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有该程序运行结束之后才能调入下一道程序。<strong>CPU 有大量的时间是在空闲等待 I/O 完成</strong>。资源利用率依然很低。</li>
</ul>
</li>
<li>多道批处理系统
<ul>
<li>操作系统正式诞生，用于支持多道程序并发运行。</li>
<li>每次往内存中读入多道程序。</li>
<li>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。<strong>资源利用率大幅提升</strong>，CPU 和其他资源更能保持“忙碌”状态，系统吞吐量增大。</li>
<li>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。eg. 无法调试程序/无法在程序运行过程中输入一些参数）</li>
</ul>
</li>
<li>分时操作系统
<ul>
<li>计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。</li>
<li>主要优点：用户请求可以被及时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</li>
<li>主要缺点：<strong>不能优先处理一些紧急系统</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</li>
</ul>
</li>
<li>实时操作系统
<ul>
<li>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。</li>
<li>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。</li>
<li>分类：
<ul>
<li>硬实时系统：必须在绝对严格的规定时间内完成处理，如：导弹控制系统、自动驾驶系统。</li>
<li>软实时系统：能接受偶尔违反时间规定，如：12306 火车订票系统。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="1-3-操作系统的运行机制">1.3 操作系统的运行机制</h2>
<ul>
<li>
<p>CPU 上会运行两种程序：<strong>操作系统内核程序</strong>和<strong>应用程序</strong>。</p>
</li>
<li>
<p>CPU 有两种状态：<strong>内核态</strong>和<strong>用户态</strong>。</p>
</li>
<li>
<p>处于<strong>内核态</strong>时，说明此时正在<strong>运行的是内核程序</strong>，此时<strong>可以执行特权指令</strong>。</p>
</li>
<li>
<p>处于用户态时，说明此时正在<strong>运行的是应用程序</strong>，此时<strong>只能执行非特权指令</strong>。</p>
</li>
<li>
<p>拓展：CPU 有一个寄存器叫程序状态寄存器（PSW），其中有个二进制位，分别表示内核态和用户态。</p>
</li>
<li>
<p>别名：内核态=核心态=<strong>管态</strong>；用户态=<strong>目态</strong>。</p>
</li>
<li>
<p>内核态、用户态的切换</p>
<ul>
<li>案例：
<ol>
<li>刚开机时，CPU 为“内核态”，操作系统内核程序先上 CPU 运行；</li>
<li>开机完成后，用户可以启动某个应用程序；</li>
<li>操作系统内核程序在合适的时候主动让出 CPU，让该应用程序上 CPU 运行（操作系统内核在让出 CPU 之前，会<strong>用一条特权指令把 PSW 的标志位设置为“用户态”</strong>）；</li>
<li>应用程序运行在“用户态”；</li>
<li>此时有一名黑客在应用程序中植入了一条特权指令，企图破坏系统……</li>
<li>CPU 发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态”；</li>
<li>这个非法事件会引发一个<strong>中断信号</strong>（<strong>CPU 检测到中断信号后</strong>，会立即<strong>变为“核心态</strong>”，并停止运行当前的应用程序，转而运行处理中断信号的内核程序）；</li>
<li>“中断”使操作系统再次夺回 CPU 的控制权；</li>
<li>操作系统会对引发中断的事件进行处理，处理完了再把 CPU 使用权交给别的应用程序。</li>
</ol>
</li>
<li>状态转换
<ul>
<li><strong>内核态 --&gt; 用户态</strong>：执行一条<strong>特权指令</strong>——<strong>修改 PSW</strong> 的标志位为“用户态”，这个动作意味着操作系统将主动让出 CPU 使用权。</li>
<li><strong>用户态 --&gt; 内核态</strong>：由**“中断”**引发，<strong>硬件自动完成变态过程</strong>，触发中断信号意味着操作系统将强行夺回 CPU 的使用权。（除了非法使用特权指令之外，还有很多事件会触发中断信号。一个共性是，<strong>但凡需要操作系统介入的地方，都会触发中断信号</strong>）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>中断和异常</p>
<ul>
<li><strong>中断</strong>是让操作系统内核夺回 CPU 使用权的唯一途径。</li>
<li>中断的类型：
<ul>
<li>内中断（异常）：与当前执行的指令<strong>有关</strong>，中断信号来源于 CPU <strong>内部</strong>；
<ul>
<li>分类：
<ol>
<li>陷阱、陷入 trap：由陷入指令引发，是应用程序故意引发的。</li>
<li>故障 fault：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把 CPU 使用权还给应用程序，让它继续执行下去。</li>
<li>终止 abort：由致命错误引起，内核程序无法修复该错误，因此一般不再将 CPU 使用权还给引发终止的应用程序，而是直接终止该应用程序。</li>
</ol>
</li>
<li>例：
<ol>
<li>试图在用户态下执行特权指令；</li>
<li>执行除法指令时发现除数为 0；</li>
<li>有时候应用程序想请求操作系统内核的服务，此时会执行一条<strong>特殊的指令——陷入指令</strong>，该指令会引发一个内部中断信号。</li>
</ol>
</li>
</ul>
</li>
<li>外中断：与当前执行的指令<strong>无关</strong>，中断信号来源于 CPU <strong>外部</strong>。
<ul>
<li>例：
<ol>
<li>时钟中断——由时钟部件发来的中断信号；</li>
<li>I/O 中断——由输入/输出设备发来的中断信号。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>中断机制的基本原理
<ul>
<li><strong>不同的中断信号，需要用不同的中断处理程序来处理</strong>。当 CPU 检测到中断信号后，会根据中断信号的类型去查询“<strong>中断向量表</strong>”，以此来找到相应的中断处理程序在内存中的存放位置。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>系统调用</p>
<ul>
<li>
<p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong>。</p>
</li>
<li>
<p>系统调用与库函数的区别</p>
<ul>
<li>有的库函数是对系统调用的进一步封装；</li>
<li>有的库函数没有使用系统调用。</li>
</ul>
<table>
<thead>
<tr>
<th>普通应用程序</th>
<th>可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及</th>
</tr>
</thead>
<tbody>
<tr>
<td>编程语言</td>
<td>向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便</td>
</tr>
<tr>
<td>操作系统</td>
<td>向上提供系统调用，使得上层程序能请求内核的服务</td>
</tr>
<tr>
<td>裸机</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>为什么系统调用是必须的？</p>
<ul>
<li>情景：如果两个打印进程并发运行，打印机设备交替地收到这两个进程发来的打印请求，会将内容混杂在一起输出。</li>
<li>解决方法：由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用”，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。</li>
</ul>
</li>
<li>
<p>什么功能要用到系统调用？</p>
<ul>
<li>按功能分类：
<ul>
<li>设备管理：完成设备的请求/释放/启动等功能</li>
<li>文件管理：完成文件的读/写/创建/删除等功能</li>
<li>进程管理：完成进程的创建/撤销/阻塞/唤醒等功能</li>
<li>进程通信：完成进程之间的消息传递/信号传递等功能</li>
<li>内存管理：完成内存的分配/回收等功能</li>
</ul>
</li>
<li>应用程序通过<strong>系统调用</strong>请求操作系统的服务。而系统中的各种共享资源都有操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作（如存储分配、I/O 操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成。这样可以保证系统的<strong>稳定性</strong>和<strong>安全性</strong>，防止用户进行非法操作。</li>
</ul>
</li>
<li>
<p>系统调用的过程</p>
<ul>
<li>传递系统调用参数 --&gt; 执行陷入指令（<strong>用户态</strong>）–&gt; 执行相应的内核程序处理系统调用（<strong>核心态</strong>）–&gt; 返回应用程序</li>
<li>注：
<ol>
<li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使 CPU 进入核心态</li>
<li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li>
<li>注意别名：陷入指令 = trap 指令 = 访管指令</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-4-操作系统体系结构">1.4 操作系统体系结构</h2>
<ul>
<li><strong>内核</strong>是操作系统最基本、最核心的部分，实现操作系统内核功能的程序就是<strong>内核程序</strong>。</li>
</ul>
<p><img src="../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240901211137238.png" alt="image-20240901211137238"></p>
<ul>
<li>
<p>分层结构</p>
<ul>
<li>内核分多层，每层可单向调用更低一层提供的接口。</li>
<li>优点：
<ul>
<li>便于调试和验证，自底向上逐层调试验证；</li>
<li>易扩充和易维护，各层之间调用接口清晰固定。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>仅可调用相邻低层，难以合理定义各层的边界；</li>
<li>效率低，不可跨层调用，系统调用执行时间长。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>模块化</p>
<ul>
<li>将内核划分为多个模块，各模块之间相互协作。</li>
<li>内核 = 主模块 + 可加载内核模块</li>
<li>主模块：只负责核心功能，如进程调度、内存管理</li>
<li>可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核。</li>
<li>优点：
<ul>
<li>模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发；</li>
<li>支持动态加载新的内核模块（如：安装设备驱动程序、安装新的文件系统模块到内核），增强 OS 适应性；</li>
<li>任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>模块间的接口定义未必合理、实用；</li>
<li>模块间相互依赖，更难调试和验证。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>宏内核（大内核）</p>
<ul>
<li>
<p>所有的系统功能都放在内核里（大内核结构的 OS 通常也采用了“模块化”的设计思想）</p>
</li>
<li>
<p>优点：</p>
<ul>
<li>性能高，内核内部各种功能都可以直接相互调用。</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>内核庞大功能复杂，难以维护；</li>
<li>大内核中某个功能模块出错，就可能导致整个系统崩溃。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>微内核</p>
<ul>
<li>只把中断、原语、进程通信等最核心的功能放入内核。进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态。</li>
<li>优点：
<ul>
<li>内核小功能少、易于维护，内核可靠性高；</li>
<li>内核外的某个功能模块出错不会导致整个系统崩溃。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>性能低，需要频繁的切换用户态和核心态。用户态下的各功能模块不可以直接相互调用，只能通过内核的“消息传递”来间接通信。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>外核</p>
<ul>
<li>内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全。</li>
<li>优点：
<ul>
<li>外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源；</li>
<li>减少了虚拟硬件资源的“映射层”，提升效率。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>降低了系统的一致性；</li>
<li>使系统变得更复杂。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-5-操作系统的引导">1.5 操作系统的引导</h2>
<ol>
<li>CPU 从一个特定主存地址开始，取指令，执行 ROM 中的引导程序（先进行硬件自检，再开机）</li>
<li>将磁盘的第一块——主引导记录读入内存，执行磁盘引导程序，扫描分区表</li>
<li>从活动分区（又称主分区，即安装了操作系统的分区）读入分区引导记录，执行其中的程序</li>
<li>从根目录下找到完整的操作系统初始化程序（即启动管理器）并执行，完成“开机”的一系列动作</li>
</ol>
<h2 id="1-6-虚拟机">1.6 虚拟机</h2>
<ul>
<li>
<p>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（Virtual Machine，VM），每个虚拟机器都可以独立运行一个操作系统。</p>
</li>
<li>
<p>同义术语：虚拟机管理程序/虚拟机监控程序（Virtrual Machine Monitor/Hypervisor）</p>
</li>
<li>
<p>两类虚拟机程序（VMM）的对比</p>
<table>
<thead>
<tr>
<th></th>
<th>第一类 VMM</th>
<th>第二类 VMM</th>
</tr>
</thead>
<tbody>
<tr>
<td>对物理资源的控制权</td>
<td>直接运行在硬件之上，能直接控制和分配物理资源</td>
<td>运行在 Host OS 之上，依赖于 Host OS 为其分配物理资源</td>
</tr>
<tr>
<td>资源分配方式</td>
<td>在安装 Guest OS 时，VMM 要在原本的硬盘上自行分配存储空间，类似于“外核”的分配方式，分配未经抽象的物理硬件</td>
<td>Guest OS 拥有自己的虚拟硬盘，该盘实际上是 Host OS 文件系统的一个大文件。Guest OS 分配到的内存是虚拟内存</td>
</tr>
<tr>
<td>性能</td>
<td>性能更好</td>
<td>性能更差，需要 Host OS 作为“中介”</td>
</tr>
<tr>
<td>可支持的虚拟机数量</td>
<td>更多，不需要和 Host OS 竞争资源，相同的硬件资源可以支持更多的虚拟机。</td>
<td>更少，Host OS 本身需要使用物理资源，Host OS 上运行的其他进程也需要物理资源</td>
</tr>
<tr>
<td>虚拟机的可迁移性</td>
<td>更差</td>
<td>更好，只需导出虚拟机镜像文件即可迁移到另一台 Host OS 上，商业化应用更广泛</td>
</tr>
<tr>
<td>运行模式</td>
<td>第一类 VMM 运行在最高特权级（Ring 0），可以执行最高特权的指令</td>
<td>第二类 VMM 部分运行在用户态、部分运行在内核态。Guest OS 发出的系统调用会被 VMM 截获，并转化为 VMM 对 Host OS 的系统调用</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h1 id="第二章-处理机管理">第二章 处理机管理</h1>
<h2 id="2-1-进程与线程">2.1 进程与线程</h2>
<h3 id="2-1-1-进程的概念-组成-特征">2.1.1 进程的概念、组成、特征</h3>
<ul>
<li>
<p>进程的概念</p>
<ul>
<li>程序：是<strong>静态</strong>的，就是个存放在磁盘里的可执行文件，就是一系列的指令集和。</li>
<li>进程（Process）：是<strong>动态</strong>的，是程序的一次执行过程。</li>
<li>一个<strong>进程实体</strong>（进程映像）由 PCB、<strong>程序段</strong>、<strong>数据段</strong>组成。进程是<strong>动态</strong>的，进程实体（进程映像）是静态的。</li>
<li>进程实体反应了进程在某一时刻的状态。</li>
<li>PCB 是给操作系统使用的，程序段、数据段是给进程自己用的，与进程自身的运行逻辑有关。</li>
<li>引入了进程实体的概念后，可把进程定义为：进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位。</li>
<li>一个进程被“调度”，就是指操作系统决定让这个进程上 CPU 运行。</li>
</ul>
</li>
<li>
<p>进程的组成——PCB</p>
<ul>
<li>
<p>当进程被创建时，操作系统会为该进程分配一个<strong>唯一的</strong>、<strong>不重复的</strong>“身份证号”——<strong>PID</strong>（Process ID，进程 ID）</p>
</li>
<li>
<p>操作系统要记录 PID、进程所属用户 ID（UID），还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些 I/O 设备、正在使用哪些文件），还要记录进程的运行情况（如：CPU 使用时间、磁盘使用情况、网络流量使用情况等），这些信息都被保存在一个数据结构 <strong>PCB</strong>（Process Control Block）中，即<strong>进程控制块</strong>。操作系统需要对各个并发运行的进程进行管理，<strong>但凡管理时所需要的的信息，都会被放在 PCB 中</strong>。</p>
</li>
<li>
<p>PCB 是进程存在的唯一标识，当进程被创建时，操作系统为其创建 PCB，当进程结束时，会回收其 PCB。</p>
</li>
<li>
<p>PCB 包含进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息。</p>
</li>
</ul>
</li>
<li>
<p>进程的组成——程序段</p>
<ul>
<li>包含程序指令</li>
</ul>
</li>
<li>
<p>进程的组成——数据段</p>
<ul>
<li>包含运行过程中产生的各种数据</li>
</ul>
</li>
<li>
<p>进程的特征</p>
<ul>
<li>动态性（进程最基本的特性）：进程是程序的一次执行过程，是动态地产生、变化和消亡的；</li>
<li>并发性：内存中有多个进程实体，各进程可并发执行；</li>
<li>独立性：进程是能够独立运行、独立获得资源、独立接收调度的基本单位；</li>
<li>异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题；</li>
<li>结构性：每个进程都会配置一个 PCB。结构上看，进程由程序段、数据段、PCB 组成。</li>
</ul>
</li>
</ul>
<h3 id="2-1-2-进程的状态与转换-进程的组织">2.1.2 进程的状态与转换、进程的组织</h3>
<ul>
<li>
<p>进程的状态</p>
<ol>
<li>创建态（新建态）：进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化 PCB。</li>
<li><strong>就绪态</strong>：当进程创建完成后，便进入“就绪态”，处于就绪态的进程已经具备运行条件，但由于没有空闲 CPU，就暂时不能运行。</li>
<li><strong>运行态</strong>：进程占有 CPU，并在 CPU 上运行。</li>
<li><strong>阻塞态</strong>（等待态）：在进程运行的过程中，可能会请求等待某个事件的发生。在这个事件发生之前，进程无法啊继续往下执行，此时操作系统会让这个进程下 CPU，并让它进入“阻塞态”。</li>
<li>终止态（结束态）：一个进程可以执行 exit 系统调用，请求操作系统终止该进程。此时该进程会进入“终止态”，操作系统会让该进程下 CPU，并回收内存空间等资源，最后还要回收该进程的 PCB。当终止进程的工作完成之后，这个进程就彻底消失了。</li>
</ol>
</li>
<li>
<p>三种基本状态：运行态、就绪态和阻塞态。</p>
</li>
<li>
<p>单 CPU 情况下，同一时刻只会有一个进程处于运行态，多核 CPU 情况下可能有多个进程处于运行态。</p>
</li>
<li>
<p>进程状态的转换</p>
<p><img src="../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240904184047675.png" alt="image-20240904184047675"></p>
<ul>
<li>运行 -&gt; 阻塞态是一种进程自身做出的<strong>主动行为</strong>。</li>
<li>阻塞 -&gt; 就绪态不是进程本身能控制的，是一种<strong>被动行为</strong>。</li>
<li><strong>注意：不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态</strong>。</li>
</ul>
</li>
<li>
<p><strong>进程 PCB 中，会有一个变量 state 来表示进程的当前状态</strong>。为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的 PCB 组织起来。</p>
</li>
<li>
<p>进程的组织方式</p>
<ul>
<li>
<p>链接方式</p>
<ul>
<li>按照进程状态将 PCB 分为多个队列，操作系统持有指向各个队列的指针。</li>
<li>执行指针：指向当前处于运行态的进程。（单 CPU 计算机中，同一时刻只会有一个进程处于运行态）</li>
<li>就绪队列指针：指向当前处于就绪态的进程。通常会把优先级高的进程放在队头。</li>
<li>阻塞队列指针：指向当前处于阻塞态的进程。很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列（如：等待打印机的阻塞队列、等待磁盘的阻塞队列）</li>
</ul>
</li>
<li>
<p>索引方式</p>
<ul>
<li>根据进程状态的不同，建立几张索引表，操作系统持有指向各个索引表的指针。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-1-3-进程控制">2.1.3 进程控制</h3>
<ul>
<li>
<p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p>
</li>
<li>
<p>简化理解：进程控制就是要实现进程状态转换。</p>
</li>
<li>
<p>用“原语”实现进程控制。</p>
<ul>
<li><strong>原语</strong>是一种特殊的程序，它的执行具有<strong>原子性</strong>。也就是说，这段程序的<strong>运行必须一气呵成，不可中断</strong>。</li>
<li>可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性。</li>
<li>CPU 执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。</li>
</ul>
</li>
<li>
<p>进程控制相关的原语</p>
<ul>
<li>进程的创建
<ul>
<li>创建原语
<ul>
<li>申请空白 PCB</li>
<li>为新进程分配所需资源</li>
<li>初始化 PCB</li>
<li>将 PCB 插入就绪队列</li>
</ul>
</li>
<li>引起进程创建的事件
<ul>
<li>用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程</li>
<li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>
<li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>
<li>应用请求：由用户进程主动请求创建一个子进程</li>
</ul>
</li>
</ul>
</li>
<li>进程的终止
<ul>
<li>撤消原语
<ul>
<li>从 PCB 集合中找到终止进程的 PCB</li>
<li>若进程正在运行，立即剥夺 CPU，将 CPU 分配给其他进程</li>
<li>终止其所有子进程</li>
<li>将该进程有的所有资源归还给父进程或操作系统</li>
<li>删除 PCB</li>
</ul>
</li>
<li>引起进程终止的事件
<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
</li>
</ul>
</li>
<li>进程的阻塞
<ul>
<li>阻塞原语
<ul>
<li>找到要阻塞的进程对应的 PCB</li>
<li>保护进程运行现场，将 PCB 状态信息设置为“阻塞态”，暂时停止进程运行</li>
<li>将 PCB 插入相应事件的等待队列</li>
</ul>
</li>
<li>引起进程阻塞的事件
<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
</li>
</ul>
</li>
<li>进程的唤醒
<ul>
<li>唤醒原语
<ul>
<li>在事件等待队列中找到 PCB</li>
<li>将 PCB 从等待队列移除，设置进程为就绪态</li>
<li>将 PCB 插入就绪队列，等待被调度</li>
</ul>
</li>
<li>引起进程唤醒的事件
<ul>
<li>等待的事件发生</li>
</ul>
</li>
</ul>
</li>
<li>进程的切换
<ul>
<li>切换原语
<ul>
<li>将运行环境信息存入 PCB</li>
<li>PCB 移入相应队列</li>
<li>选择另一个进程执行，并更新其 PCB</li>
<li>根据 PCB 恢复新进程所需的运行环境</li>
</ul>
</li>
<li>引起进程切换的事件
<ul>
<li>当前进程时间片到</li>
<li>有高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-1-4-进程通信">2.1.4 进程通信</h3>
<ul>
<li>进程间通信（Inter-Process Communication，IPC）是指两个或以上进程之间产生数据交互。</li>
<li>为什么进程通信需要操作系统支持？
<ul>
<li>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong>。</li>
<li>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。</li>
</ul>
</li>
<li>进程通信的三种方式
<ul>
<li>共享存储</li>
<li>消息传递</li>
<li>管道通信</li>
</ul>
</li>
<li>共享存储
<ul>
<li>两种共享方式：
<ul>
<li>基于<strong>数据结构</strong>的共享：比如共享空间里只能放一个长度为 10 的数组。这种共享方式速度慢、限制多，是一种<strong>低级通信</strong>方式。</li>
<li>基于<strong>存储区</strong>的共享：操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种<strong>高级通信</strong>方式。</li>
</ul>
</li>
<li>为避免出错，各个进程对共享空间的<strong>访问</strong>是<strong>互斥</strong>的。各个进程可使用操作系统内核提供的同步互斥工具（如 P、V 操作）。</li>
</ul>
</li>
<li>消息传递
<ul>
<li>进程间的数据交换以<strong>格式化的消息</strong>（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。</li>
<li>格式化的消息包含两个部分：
<ul>
<li>消息头：包括发送进程 ID、接收进程 ID、消息长度等格式化的信息；</li>
<li>消息体：要传递的内容。</li>
</ul>
</li>
<li>两种通信方式：
<ul>
<li>直接通信方式：消息发送过程要指明接收进程的 ID。</li>
<li>间接通信方式：通过“信箱”间接地通信。因此又称“信箱通信方式”。可以多个进程往同一个信箱里 send 消息，也可以多个进程从同一个信箱中 receive 消息。</li>
</ul>
</li>
</ul>
</li>
<li>管道通信
<ul>
<li>“管道”是一个特殊的共享文件，又名 pipe 文件。其实就是在内存中开辟一个大小固定的内存缓冲区。</li>
<li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则<strong>需要设置两个管道</strong>。</li>
<li>各进程要<strong>互斥</strong>地访问管道（由操作系统实现）。</li>
<li>当<strong>管道写满</strong>时，<strong>写进程</strong>将<strong>阻塞</strong>，直到读进程将管道中的数据取走，即可唤醒写进程。</li>
<li>当<strong>管道读空</strong>时，<strong>读进程</strong>将<strong>阻塞</strong>，直到写进程往管道中写入数据，即可唤醒读进程。</li>
<li>管道中的数据一旦被读出，就彻底消失。因此当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：
<ol>
<li>一个管道允许多个写进程，但只允许一个读进程；</li>
<li>允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="2-1-5-线程的概念">2.1.5 线程的概念</h3>
<ul>
<li>可以把线程理解为”轻量级进程“。<strong>线程</strong>是一个<strong>基本的 CPU 执行单元</strong>，也是<strong>程序执行流的最小单位</strong>。引入线程之后，不仅是进程之间可以并发，进程内的<strong>各线程之间</strong>也可以<strong>并发</strong>，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内也可以并发处理各种任务（如 QQ 视频、文字聊天、传文件）。</li>
<li>引入线程后，<strong>进程</strong>只作为<strong>除 CPU 之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的）。</li>
<li>传统的进程间并发，需要切换进程的运行环境，系统开销很大。线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小。引入线程后，并发所带来的系统开销减少。</li>
<li>线程的属性
<ul>
<li>线程是处理机调度的单位。</li>
<li>多 CPU 计算机中，各个线程可占用不同的 CPU。</li>
<li>每个线程都有一个线程 ID、线程控制块（TCB）。</li>
<li>线程也有就绪、阻塞、运行三种基本状态。</li>
<li>线程几乎不拥有系统资源。</li>
<li>同一进程的不同线程间共享进程的资源。</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预。</li>
<li>同一进程中的线程切换，不会引起进程切换。不同进程中的线程切换，会引起进程切换。</li>
<li>切换同进程内的线程，系统开销很小。切换进程，系统开销较大。</li>
</ul>
</li>
</ul>
<h3 id="2-1-6-线程的实现方式和多线程模型">2.1.6 线程的实现方式和多线程模型</h3>
<ul>
<li>用户级线程（User-Level Thread，ULT）
<ul>
<li>历史背景：早期的操作系统只支持进程，不支持线程。当时的”线程“是由线程库实现的。</li>
<li>很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。</li>
<li>用户级线程由应用程序通过线程库实现，所有的<strong>线程管理工作</strong>都由<strong>应用程序负责</strong>（包括线程切换）。</li>
<li>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态下即可完成</strong>，无需操作系统干预。</li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。”<strong>用户级线程</strong>“就是”<strong>从用户视角看能看到的线程</strong>“。</li>
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。</li>
<li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</li>
</ul>
</li>
<li>内核级线程（Kernel-Level Thread，KLT）
<ul>
<li><strong>内核级线程的管理工作</strong>由<strong>操作系统内核</strong>完成。</li>
<li>线程调度、切换等工作都有内核负责，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成。</li>
<li>操作系统会为每个内核级线程建立相应的 TCB，通过 TCB 对线程进程管理。”<strong>内核级线程</strong>“就是”<strong>从操作系统内核视角看能看到的线程</strong>“。</li>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li>
<li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li>
</ul>
</li>
<li>多线程模型
<ul>
<li>一对一模型
<ul>
<li>一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</li>
<li>优缺点同<code>内核级线程</code>。</li>
</ul>
</li>
<li>多对一模型
<ul>
<li>多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</li>
<li>优缺点同<code>用户级线程</code>。</li>
<li>注：操作系统只”看得见“内核级线程，因此<strong>只有内核级线程才是处理机分配的单位</strong>。</li>
</ul>
</li>
<li>多对多模型
<ul>
<li>n 个用户级线程映射到 m 个内核级线程（<strong>n <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>​ m</strong>）。每个用户进程对应 m 个内核级线程。</li>
<li>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-处理机的调度">2.2 处理机的调度</h2>
<h3 id="2-2-1-调度的概念-层次">2.2.1 调度的概念、层次</h3>
<ul>
<li>
<p>概念：当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则</strong>来<strong>决定</strong>处理这些任务的<strong>顺序</strong>，这就是”调度“研究的问题。</p>
</li>
<li>
<p>调度的三个层次</p>
<ul>
<li>高级调度（作业调度）
<ul>
<li>作业：一个具体的任务。</li>
<li>定义：按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。<strong>每个作业只调入一次，调出一次</strong>。作业调入时会建立 PCB，调出时才撤销 PCB。</li>
</ul>
</li>
<li>低级调度（进程调度/处理机调度）
<ul>
<li>定义：按照某种策略从就绪队列中选取一个进程，将处理及分配给它。</li>
<li>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。</li>
<li>进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</li>
</ul>
</li>
<li>中级调度（内存调度）
<ul>
<li>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</li>
<li>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。被挂起的进程 PCB 会被组织成<strong>挂起队列</strong>。</li>
<li>定义：按照某种策略决定将哪个处于挂起状态的进程重新调入内存。</li>
<li>一个进程可能会被多次调出、调入内存，因此<strong>中级调度</strong>发生的<strong>频率</strong>要比高级调度<strong>更高</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>进程的挂起态</p>
<ul>
<li>
<p>暂时调到外存等待的进程状态为<strong>挂起状态</strong>（挂起态，suspend）。</p>
</li>
<li>
<p>挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态。</p>
</li>
<li>
<p>五状态模型 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>​ 七状态模型</p>
<p><img src="../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241024211523829.png" alt="image-20241024211523829"></p>
</li>
<li>
<p>注意”挂起“和”阻塞“的区别，两种状态都是暂时不能获得 CPU 的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。</p>
</li>
<li>
<p>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p>
</li>
</ul>
</li>
<li>
<p>三层调度的联系、对比</p>
<table>
<thead>
<tr>
<th></th>
<th>要做什么</th>
<th>调度发生在……</th>
<th>发生频率</th>
<th>对进程状态的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>高级调度（作业调度）</td>
<td>按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程</td>
<td>外存 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 内存（面向作业）</td>
<td>最低</td>
<td>无 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 创建态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 就绪态</td>
</tr>
<tr>
<td>中级调度（内存调度）</td>
<td>按照某种策略决定将哪个处于挂起状态的进程重新调入内存</td>
<td>外存 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 内存（面向进程）</td>
<td>中等</td>
<td>挂起态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 就绪态（阻塞挂起 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 阻塞态）</td>
</tr>
<tr>
<td>低级调度（进程调度）</td>
<td>按照某种策略从就绪队列中选取一个进程，将处理及分配给它</td>
<td>内存 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> CPU</td>
<td>最高</td>
<td>就绪态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 运行态</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="2-2-2-进程调度的时机-切换与过程-方式">2.2.2 进程调度的时机、切换与过程、方式</h3>
<h4 id="2-2-2-1-进程调度的时机">2.2.2.1 进程调度的时机</h4>
<ul>
<li><strong>需要进行</strong>进程调度与切换的情况
<ul>
<li>当前运行的进程<strong>主动放弃</strong>处理机
<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞（如等待 I/O）</li>
</ul>
</li>
<li>当前运行的进程<strong>被动放弃</strong>处理机
<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理（如 I/O 中断）</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
</li>
<li><strong>不能进行</strong>进程调度与切换的情况
<ul>
<li>在<strong>处理中断的过程中</strong>。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li>
<li>进程在<strong>操作系统内核程序临界区</strong>中。</li>
<li>在<strong>原子操作过程</strong>（原语）中。原子操作不可中断，要一气呵成。</li>
</ul>
</li>
<li>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要<strong>互斥</strong>地访问临界资源。</li>
<li>临界区：访问临界资源的那段代码。</li>
<li><strong>内核程序临界区</strong>一般是用来访问<strong>某种内核数据结构</strong>的，比如进程的就绪队列（由各就绪进程的 PCB 组成）</li>
<li>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。</li>
<li>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</li>
</ul>
<h4 id="2-2-2-2-进程调度的方式">2.2.2.2 进程调度的方式</h4>
<ul>
<li><strong>非剥夺调度方式</strong>，又称<strong>非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
<ul>
<li>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。</li>
</ul>
</li>
<li><strong>剥夺调度方式</strong>，又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。
<ul>
<li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统。</li>
</ul>
</li>
<li>“狭义的进程调度”与“进程切换”的区别：
<ul>
<li><strong>狭义的进程调度</strong>指的是从就绪队列中<strong>选中一个要运行的进程</strong>。（这个进程可以是刚刚被暂停执行的进程，也可能是<strong>另一个进程</strong>，后一种情况就需要<strong>进程切换</strong>）</li>
<li><strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程。</li>
<li><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤。</li>
</ul>
</li>
<li>进程切换的过程主要完成了：
<ol>
<li>对原来运行进程各种数据的保存；</li>
<li>对新的进程各种数据的恢复。</li>
</ol>
</li>
<li>注意：<strong>进程切换是有代价的</strong>，因此如果<strong>过于频繁</strong>的进行进程<strong>调度</strong>、<strong>切换</strong>，必然会使整个<strong>系统的效率降低</strong>，使系统大部分时间都花在了进程切换上，而真正用于执行进程的事件减少。</li>
</ul>
<h3 id="2-2-3-调度算法的评价指标">2.2.3 调度算法的评价指标</h3>
<ol>
<li>
<p>CPU 利用率</p>
<ul>
<li>
<p>由于早期的 CPU 造价极其昂贵，因此人们会希望让 CPU 尽可能多地工作。</p>
</li>
<li>
<p><strong>CPU 利用率</strong>：指 CPU“忙碌”的事件占总时间的比例。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>利用率</mtext><mo>=</mo><mfrac><mtext>忙碌的时间</mtext><mtext>总时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">利用率=\frac{忙碌的时间}{总时间}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">利</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">率</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">忙</span><span class="mord cjk_fallback">碌</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
</ul>
</li>
<li>
<p>系统吞吐量</p>
<ul>
<li>
<p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业。</p>
</li>
<li>
<p><strong>系统吞吐量</strong>：单位时间内完成作业的数量。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>系统吞吐量</mtext><mo>=</mo><mfrac><mtext>总共完成了多少道作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">系统吞吐量=\frac{总共完成了多少道作业}{总共花了多少时间}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">系</span><span class="mord cjk_fallback">统</span><span class="mord cjk_fallback">吞</span><span class="mord cjk_fallback">吐</span><span class="mord cjk_fallback">量</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">共</span><span class="mord cjk_fallback">花</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">少</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">共</span><span class="mord cjk_fallback">完</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">少</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
</ul>
</li>
<li>
<p>周转时间</p>
<ul>
<li>
<p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。</p>
</li>
<li>
<p><strong>周转时间</strong>：指从<strong>作业被提交给系统开始</strong>，到<strong>作业完成为止</strong>的这段时间间隔。</p>
</li>
<li>
<p>周转时间包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在 CPU 上执行的时间、进程等待 I/O 操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>周转时间</mtext><mo>=</mo><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext><mspace linebreak="newline"></mspace><mtext>平均周转时间</mtext><mo>=</mo><mfrac><mtext>各作业周转时间之和</mtext><mtext>作业数</mtext></mfrac><mspace linebreak="newline"></mspace><mtext>带权周转时间</mtext><mo>=</mo><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行的时间</mtext></mfrac><mo>=</mo><mfrac><mrow><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow><mtext>作业实际运行的时间</mtext></mfrac><mspace linebreak="newline"></mspace><mtext>平均带权周转时间</mtext><mo>=</mo><mfrac><mtext>各作业带权周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">周转时间=作业完成时间-作业提交时间\\
平均周转时间=\frac{各作业周转时间之和}{作业数}\\
带权周转时间=\frac{作业周转时间}{作业实际运行的时间}=\frac{作业完成时间-作业提交时间}{作业实际运行的时间}\\
平均带权周转时间=\frac{各作业带权周转时间之和}{作业数}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">完</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">提</span><span class="mord cjk_fallback">交</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">平</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">各</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">和</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">带</span><span class="mord cjk_fallback">权</span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">际</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">际</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">完</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">提</span><span class="mord cjk_fallback">交</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">平</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">带</span><span class="mord cjk_fallback">权</span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">各</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">业</span><span class="mord cjk_fallback">带</span><span class="mord cjk_fallback">权</span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">和</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
</ul>
</li>
<li>
<p>等待时间</p>
<ul>
<li>计算机的用户希望自己的作业尽可能少的等待处理机。</li>
<li><strong>等待时间</strong>：指进程/作业<strong>处于等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</li>
<li>对于<strong>进程</strong>来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待 I/O 完成的期间其实进程也是在被服务的，所以不计入等待时间。</li>
<li>对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后的等待时间</strong>，<strong>还要加上作业在外存后备队列中等待的时间</strong>。</li>
<li>一个作业总共需要被 CPU 服务多久，被 I/O 设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“<strong>平均等待时间</strong>”来评价整体性能。</li>
</ul>
</li>
<li>
<p>响应时间</p>
<ul>
<li>对于计算机用户来说，会希望自己提交的请求尽早地开始被系统服务、回应。</li>
<li><strong>响应时间</strong>：指从用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间。</li>
</ul>
</li>
</ol>
<h3 id="2-2-4-调度算法">2.2.4 调度算法</h3>
<h4 id="2-2-4-1-先来先服务-fcfs-first-come-first-serve">2.2.4.1 先来先服务（FCFS，First Come First Serve）</h4>
<ul>
<li>算法思想：主要从“公平”的角度考虑。</li>
<li>算法规则：按照作业/进程到达的先后顺序进行服务。</li>
<li>用于作业/进程调度：用于作业调度时，考虑的是那个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。</li>
<li>是否可抢占：非抢占式的算法。</li>
<li>优缺点：
<ul>
<li>优点：公平、算法实现简单；</li>
<li>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS 算法<strong>对长作业有利，对短作业不利</strong>。</li>
</ul>
</li>
<li>是否会导致饥饿：不会。</li>
</ul>
<h4 id="2-2-4-2-短作业优先-sjf-shortest-job-first">2.2.4.2 短作业优先（SJF，Shortest Job First）</h4>
<ul>
<li>算法思想：追求最少的平均等待时间、最少的平均周转时间、最少的平均带权周转时间。</li>
<li>算法规则：最短的作业/进程优先得到服务。</li>
<li>用于作业/进程调度：既可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先（<strong>SPF</strong>，Shortest Process First）算法。</li>
<li>是否可抢占：SJF 和 SPF 是<strong>非抢占式</strong>的算法。但是<strong>也有抢占式的版本</strong>——<strong>最短剩余时间优先算法</strong>（SRTN，Shortest Remaining Time Next）。</li>
<li>优缺点：
<ul>
<li>优点：”最短的“平均等待时间、平均周转时间。</li>
<li>缺点：不公平。<strong>对短作业有利，对长作业不利</strong>。可能产生<strong>饥饿</strong>现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</li>
</ul>
</li>
<li>是否会导致饥饿：会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生”<strong>饥饿</strong>“现象。如果一直得不到服务，则称为”<strong>饿死</strong>“。</li>
</ul>
<h4 id="2-2-4-3-高响应比优先-hrrn-highest-response-ratio-next">2.2.4.3 高响应比优先（HRRN，Highest Response Ratio Next）</h4>
<ul>
<li>
<p>算法思想：要综合考虑作业/进程的等待时间和要求服务的时间。</p>
</li>
<li>
<p>算法规则：在每次调度时先计算各个作业/进程的<strong>响应比</strong>，选择<strong>响应比最高</strong>的作业/进程为其服务。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>响应比</mtext><mo>=</mo><mfrac><mrow><mtext>等待时间</mtext><mo>+</mo><mtext>要求服务时间</mtext></mrow><mtext>要求服务时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">响应比=\frac{等待时间+要求服务时间}{要求服务时间}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">响</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">比</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">求</span><span class="mord cjk_fallback">服</span><span class="mord cjk_fallback">务</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">待</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">求</span><span class="mord cjk_fallback">服</span><span class="mord cjk_fallback">务</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
<li>
<p>用于作业/进程调度：既可用于作业调度，也可用于进程调度。</p>
</li>
<li>
<p>是否可抢占：非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比。</p>
</li>
<li>
<p>优缺点：综合考虑了等待时间和运行时间（要求服务时间）。等待时间相同时，要求服务时间短的优先（SJF 的优点）；要求服务时间相同时，等待时间长的优先（FCFS 的优点）。对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题。</p>
</li>
<li>
<p>是否会导致饥饿：不会。</p>
</li>
</ul>
<h4 id="2-2-4-4-时间片轮转调度算法-rr-round-robin">2.2.4.4 时间片轮转调度算法（RR，Round-Robin）</h4>
<ul>
<li>算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。</li>
<li>算法规则：按照各进程到达就绪队列的顺序，轮流让各进程执行一个<strong>时间片</strong>（如 100 ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li>
<li>用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</li>
<li>是否可抢占：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于<strong>抢占式</strong>的算法。由时钟装置发出<strong>时钟中断</strong>来通知 CPU 时间片已到。</li>
<li>优缺点：
<ul>
<li>优点：公平；响应快，适用于分时操作系统。</li>
<li>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li>
</ul>
</li>
<li>是否会导致饥饿：不会。</li>
<li>注：如果<strong>时间片太大</strong>，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法<strong>退化为先来先服务</strong>调度算法，并且<strong>会增大进程响应时间</strong>。因此<strong>时间片不能太大</strong>。另一方面，进程调度、切换是有时间代价的，因此如果<strong>时间片太小</strong>，会导致进<strong>程切换过于频繁</strong>，系统会花大量时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见<strong>时间片也不能太小</strong>。</li>
</ul>
<h4 id="2-2-4-5-优先级调度算法">2.2.4.5 优先级调度算法</h4>
<ul>
<li>算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。</li>
<li>算法规则：调度时选择优先级最高的作业/进程。</li>
<li>用于作业/进程调度：既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的 I/O 调度中。</li>
<li>是否可抢占：抢占式、非抢占式都有。非抢占式只需要在进程主动放弃处理机时进行调度即可，而抢占式还需要在就绪队列变化时，检查是否会发生抢占。</li>
<li>优缺点：
<ul>
<li>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。</li>
<li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿。</li>
</ul>
</li>
<li>是否会导致饥饿：会。</li>
<li>补充：
<ul>
<li>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近对头的位置。</li>
<li>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种。
<ul>
<li>静态优先级：创建进程时确定，之后一直不变；</li>
<li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li>
</ul>
</li>
<li>通常：
<ul>
<li>系统进程优先级<strong>高于</strong>用户进程；</li>
<li>前台进程优先级<strong>高于</strong>后台进程；</li>
<li>操作系统更<strong>偏好 I/O 型进程</strong>（或称 I/O 繁忙型进程）。</li>
</ul>
</li>
<li>与 I/O 型进程相对的是计算型进程（或称 CPU 繁忙型进程）。</li>
</ul>
</li>
</ul>
<h4 id="2-2-4-6-多级反馈队列调度算法">2.2.4.6 多级反馈队列调度算法</h4>
<ul>
<li>算法思想：对其他调度算法的折中权衡。</li>
<li>算法规则：
<ol>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大；</li>
<li>新进程到达时先进入第 1 级队列，按 FCFS 原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾；</li>
<li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片。</li>
</ol>
</li>
<li>用于作业/进程调度：用于进程调度。</li>
<li>是否可抢占：抢占式的算法。在 k 级队列的进程运行过程中，若有更上级的队列（1~k-1 级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。</li>
<li>优缺点：对各类型进程相对公平（FCFS 的优点）；每个新到达的进程都可以很快就得到响应（RR 的优点）；短进程只用较少的时间就可完成（SRF 的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I/O 密集型进程（拓展：可以将因 I/O 而阻塞的进程重新放回原队列，这样 I/O 型进程就可以保持较高优先级）</li>
<li>是否会导致饥饿：会。</li>
</ul>
<h2 id="2-3-进程的同步与互斥">2.3 进程的同步与互斥</h2>
<h3 id="2-3-1-进程同步-进程互斥">2.3.1 进程同步、进程互斥</h3>
<ul>
<li>进程同步：亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<strong>协调</strong>它们的<strong>工作次序</strong>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</li>
<li>进程互斥
<ul>
<li>我们把<strong>一个时间段内只允许一个进程使用</strong>的资源称为<strong>临界资源</strong>。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li>
<li>对临界资源的访问，必须<strong>互斥</strong>地进行。互斥，亦称<strong>间接制约关系</strong>。<strong>进程互斥</strong>指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</li>
</ul>
</li>
<li>对临界资源的互斥访问，可以在逻辑上分为四个部分：
<ol>
<li>进入区：负责检查是否可进入临界区，若可进入，则应设置<strong>正在访问临界资源的标识</strong>（上锁），以阻止其他进程同时进入临界区。</li>
<li>临界区：访问临界资源的那段代码。</li>
<li>退出区：负责解除<strong>正在访问临界资源的标识</strong>（解锁）。</li>
<li>剩余区：做其他处理。</li>
</ol>
</li>
<li>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：
<ol>
<li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>
<li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li>
<li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li>
<li>让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
</li>
</ul>
<h3 id="2-3-2-进程互斥的软件实现方法">2.3.2 进程互斥的软件实现方法</h3>
<h4 id="2-3-2-1-单标志法">2.3.2.1 单标志法</h4>
<ul>
<li>
<p>算法思想：两个进程在<strong>访问玩临界区后</strong>会把使用临界区的权限转交给另一个进程。也就是说是<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//turn 表示当前允许进入临界区的进程号</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>); 	<span class="comment">//1 进入区</span></span><br><span class="line">critical section; 	<span class="comment">//2 临界区</span></span><br><span class="line">turn = <span class="number">1</span>;			<span class="comment">//3	退出区</span></span><br><span class="line">remainder section; 	<span class="comment">//4	剩余区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">1</span>);	<span class="comment">//5 进入区</span></span><br><span class="line">critical section;	<span class="comment">//6 临界区</span></span><br><span class="line">turn = <span class="number">0</span>;			<span class="comment">//7	退出区</span></span><br><span class="line">remainder section;	<span class="comment">//8	剩余区</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>turn 的初值为 0，即刚开始只允许 0 号进程进入临界区。若 P1 先上处理机，则会一直卡在 5。直到 P1 的时间片用完，发生调度，切换 P0 上处理机运行。代码 1 不会卡住 P0，P0 可以正常访问临界区，在 P0 访问临界区期间即使切换回 P1，P1 依然会卡在 5。只有 P0 在退出区将 turn 改为 1 后，P1 才能进入临界区。</p>
</li>
<li>
<p>因此，该算法<strong>可以实现“同一时刻最多只允许一个进程访问临界区”</strong>。</p>
</li>
<li>
<p>缺点：只能按 P0 -&gt; P1 -&gt; P0 -&gt; P1 -&gt;……这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是 P0，而 P0 一直不访问临界区，那么虽然此时临界区空闲，但是并不允许 P1 访问。因此，<strong>单标志法</strong>存在的<strong>主要问题</strong>是：<strong>违背”空闲让进“原则</strong>。</p>
</li>
</ul>
<h4 id="2-3-2-2-双标志先检查法">2.3.2.2 双标志先检查法</h4>
<ul>
<li>
<p>算法思想：设置一个布尔类型数组 flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0]=true”意味着 0 号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标识 flag[i] 设为 true，之后开始访问临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示进入临界区意愿的数组</span></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);	<span class="comment">//1</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;		<span class="comment">//2</span></span><br><span class="line">critical section;	<span class="comment">//3</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;	<span class="comment">//4</span></span><br><span class="line">remainder section</span><br><span class="line">    </span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);	<span class="comment">//5 如果此时 P0 想进入临界区，P1 就一直循环等待</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;		<span class="comment">//6 标记为 P1 进程想要进入临界区</span></span><br><span class="line">critical section;	<span class="comment">//7 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">//8 访问完临界区，修改标记为 P1 不想使用临界区</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>缺点：若按照 1, 5, 2, 6, 3, 7,…  的顺序执行，P0 和 P1 将会同时访问临界区。因此，<strong>双标志先检查法</strong>的<strong>主要问题</strong>是：<strong>违背”忙则等待“原则</strong>。原因在于，<strong>进入区</strong>的”检查“和”上锁“<strong>两个处理不是一气呵成的</strong>。”检查“后，”上锁“前可能发生进程切换。</p>
</li>
</ul>
<h4 id="2-3-2-3-双标志后检查法">2.3.2.3 双标志后检查法</h4>
<ul>
<li>
<p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示进入临界区意愿的数组</span></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;		<span class="comment">//1</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);	<span class="comment">//2</span></span><br><span class="line">critical section;	<span class="comment">//3</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;	<span class="comment">//4</span></span><br><span class="line">remainder section</span><br><span class="line">    </span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;		<span class="comment">//5 标记为 P1 进程想要进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);	<span class="comment">//6 如果此时 P0 想进入临界区，P1 就一直循环等待</span></span><br><span class="line">critical section;	<span class="comment">//7 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">//8 访问完临界区，修改标记为 P1 不想使用临界区</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>缺点：若按照 1, 5, 2, 6, … 的顺序执行，P0 和 P1 都将无法进入临界区。因此，双标志后检查法虽然<strong>解决了“忙则等待”<strong>的问题，但是</strong>又违背了“空闲让进”和“有限等待”原则</strong>，会因各进程都长期无法访问临界资源而**产生“饥饿”**现象。</p>
</li>
</ul>
<h4 id="2-3-2-4-peterson-算法">2.3.2.4 Peterson 算法</h4>
<ul>
<li>
<p>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示进入临界区意愿的数组</span></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//表示优先让哪个进程进入临界区</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;					<span class="comment">//1</span></span><br><span class="line">turn = <span class="number">1</span>;						<span class="comment">//2</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);	<span class="comment">//3</span></span><br><span class="line">critical section;				<span class="comment">//4</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;				<span class="comment">//5</span></span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;					<span class="comment">//6</span></span><br><span class="line">turn = <span class="number">0</span>;						<span class="comment">//7</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);	<span class="comment">//8</span></span><br><span class="line">critical section;				<span class="comment">//9</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;				<span class="comment">//10</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>缺点：Peterson 算法用软件方法解决了进程互斥问题，<strong>遵循了空闲让进、忙则等待、有限等待三个原则</strong>，但是依然<strong>未遵循让权等待</strong>的原则。Peterson 算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</p>
</li>
</ul>
<h3 id="2-3-3-进程互斥的硬件实现方法">2.3.3 进程互斥的硬件实现方法</h3>
<h4 id="2-3-3-1-中断屏蔽方法">2.3.3.1 中断屏蔽方法</h4>
<ul>
<li>利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）。</li>
<li>优点：简单、高效；</li>
<li>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于有用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）。</li>
</ul>
<h4 id="2-3-3-2-testandset-指令">2.3.3.2 TestAndSet 指令</h4>
<ul>
<li>
<p>简称 TS 指令，又称 TestAndSetLock 指令，或 TSL 指令。</p>
</li>
<li>
<p>TSL 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用 C 语言描述的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布尔型共享变量 lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">//true 表示以加锁，false 表示未加锁</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">bool</span> *lock)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> old;</span><br><span class="line">    old = *lock;	<span class="comment">//old 用来存放 Lock 原来的值</span></span><br><span class="line">    *lock = <span class="literal">true</span>;	<span class="comment">//无论之前是否已加锁，都将 Lock 设为 true</span></span><br><span class="line">    <span class="keyword">return</span> old;		<span class="comment">//返回 lock 原来的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 TSL 指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span>(TestAndSet(&amp;lock));	<span class="comment">//上锁并检查</span></span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;				<span class="comment">//解锁</span></span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>相比软件实现方式，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p>
</li>
<li>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境。</p>
</li>
<li>
<p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用 CPU 并循环执行 TSL 指令，从而导致“忙等”。</p>
</li>
</ul>
<h4 id="2-3-3-3-swap-指令">2.3.3.3 Swap 指令</h4>
<ul>
<li>
<p>又称 Exchange 指令，或简称 XCHG 指令。</p>
</li>
<li>
<p>Swap 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用 C 语言描述的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Swap (<span class="type">bool</span> *a, <span class="type">bool</span> *b) &#123;</span><br><span class="line">    <span class="type">bool</span> tmp;</span><br><span class="line">    tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用 Swap 指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="comment">//lock表示当前临界区是否被加锁</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (old == <span class="literal">true</span>) Swap(&amp;lock, &amp;old);</span><br><span class="line">临界代码段...</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>优缺点同 TSL 指令。</p>
</li>
</ul>
<h3 id="2-3-4-互斥锁">2.3.4 互斥锁</h3>
<h1 id="第三章-内存管理">第三章 内存管理</h1>
<h2 id="3-1-存储器管理">3.1 存储器管理</h2>
<h3 id="3-1-1-内存的基础知识">3.1.1 内存的基础知识</h3>
<ul>
<li>
<p>内存可存放数据。程序执行前<strong>需要先放到内存中才能被 CPU 处理</strong>——缓和 CPU 与硬盘之间的速度矛盾。</p>
</li>
<li>
<p>指令的工作原理</p>
<ul>
<li>
<p>指令的工作基于“地址”。每个地址对应一个数据的存储单元。</p>
</li>
<li>
<p>程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址），即：相对于进程的起始地址而言的地址。</p>
</li>
</ul>
</li>
<li>
<p>问题：如何将指令中的逻辑地址转换为物理地址？</p>
</li>
<li>
<p>装入的三种方式：</p>
<ol>
<li><strong>绝对装入</strong>：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。
<ul>
<li>绝对装入<strong>只适用于单道程序环境</strong>。</li>
</ul>
</li>
<li><strong>静态重定位</strong>：又称<strong>可重定位装入</strong>。编译、链接后的装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“<strong>重定位</strong>”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。
<ul>
<li>静态重定位的特点是在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入改作业。</li>
<li>作业一旦进入内存后，<strong>在运行期间就不能再移动</strong>，也不能再申请内存空间。</li>
</ul>
</li>
<li><strong>动态重定位</strong>：又称<strong>动态运行时装入</strong>。编译、链接后的装入模块的地址都是从 0 开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<strong>把地址转换推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<strong>重定位寄存器</strong>的支持。
<ul>
<li>采用动态重定位时<strong>允许程序在内存中发生移动</strong>。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>从写程序到程序运行</p>
<ul>
<li>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言<strong>翻译为机器语言</strong>）。</li>
<li>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。</li>
<li>装入（装载）：由装入程序将装入模块装入内存运行。</li>
</ul>
</li>
<li>
<p>链接的三种方式：</p>
<ol>
<li>静态链接：在程序运行之前，先将各目标模块及它们所需要的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。</li>
<li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式。</li>
<li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</li>
</ol>
</li>
</ul>
<h3 id="3-1-2-内存管理的概念">3.1.2 内存管理的概念</h3>
<ul>
<li>操作系统负责<strong>内存空间的分配与回收</strong>。</li>
<li>操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong>。</li>
<li>操作系统需要提供地址转换功能，负责程序的<strong>逻辑地址</strong>与<strong>物理地址</strong>的转换。</li>
<li>操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰。</li>
<li>内存保护可采取两种方式：
<ul>
<li>方式一：在 CPU 中<strong>设置一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU 检查是否越界。</li>
<li>方式二：采用<strong>重定位寄存器</strong>（又称<strong>基址寄存器</strong>）和<strong>界地址寄存器</strong>（又称<strong>限长寄存器</strong>）进行越界检查。重定位寄存器中存放的是进程的<strong>起始物理地址</strong>。界地址寄存器中存放的是进程的<strong>最大逻辑地址</strong>。</li>
</ul>
</li>
</ul>
<h3 id="3-1-3-覆盖与交换">3.1.3 覆盖与交换</h3>
<h4 id="3-1-3-1-覆盖技术">3.1.3.1 覆盖技术</h4>
<ul>
<li>思想：将<strong>程序分为多个段</strong>（模块）。常用的段常驻内存，不常用的段在需要时调入内存。</li>
<li>内存中分为<strong>一个“固定区”<strong>和</strong>若干个“覆盖区”</strong>。</li>
<li>需要常驻内存的段放在“<strong>固定区</strong>”中，<strong>调入后就不再调出</strong>（除非运行结束）。</li>
</ul>
<p><img src="../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241027153027953.png" alt="image-20241027153027953"></p>
<ul>
<li><strong>必须由程序员声明覆盖结构</strong>，操作系统完成自动覆盖。<strong>缺点：对用户不透明</strong>，增加了用户编程负担。</li>
<li>覆盖技术只用于早期的操作系统中，现在已成为历史。</li>
</ul>
<h4 id="3-1-3-2-交换技术">3.1.3.2 交换技术</h4>
<ul>
<li>思想：内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）。</li>
<li>暂时换出外存等待的进程状态为<strong>挂起状态</strong>。</li>
<li>挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态。</li>
<li>具有交换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。<strong>文件区</strong>主要用于存放文件，<strong>追求存储空间的利用率</strong>，因此文件区空间的管理采用<strong>离散分配</strong>方式；对换区空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要<strong>追求换入换出速度</strong>，因此通常对换区采用<strong>连续分配</strong>方式。总之，<strong>对换区的 I/O 速度比文件区的更快</strong>。</li>
<li>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</li>
<li>可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被调出，有的系统还会考虑进程在内存的驻留时间……</li>
<li>注：<strong>PCB 会常驻内存</strong>，不会被换出外存。</li>
</ul>
<h3 id="3-1-4-连续分配管理方式">3.1.4 连续分配管理方式</h3>
<h4 id="3-1-4-1-单一连续分配">3.1.4.1 单一连续分配</h4>
<ul>
<li>在单一连续分配方式中，内存被分为<strong>系统区</strong>和<strong>用户区</strong>。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。</li>
<li>内存中<strong>只能有一道用户程序</strong>，用户程序独占整个用户区空间。</li>
<li>优点：实现简单；<strong>无外部碎片</strong>；可以采用覆盖技术扩充内存；不一定需要采取内存保护。</li>
<li>缺点：只能用于单用户、单任务的操作系统中；<strong>有内部碎片</strong>；存储器利用率极低。</li>
</ul>
<h4 id="3-1-4-2-固定分区分配">3.1.4.2 固定分区分配</h4>
<ul>
<li>20 世纪 60 年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个<strong>用户空间</strong>划分为<strong>若干个固定大小的分区</strong>，在<strong>每个分区中只装入一道作业</strong>，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</li>
<li>两种分区分配方式：
<ul>
<li>分区大小相等：缺乏灵活性，但是很<strong>适合用于用一台计算机控制多个相同对象的场合</strong>。</li>
<li>分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分。</li>
</ul>
</li>
<li>操作系统需要建立一个数据结构——<strong>分区说明表</strong>，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的<strong>大小、起始地址、状态</strong>（是否已分配）。</li>
<li>当某个用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。</li>
<li>优点：实现简单，<strong>无外部碎片</strong>。</li>
<li>缺点：
<ul>
<li>当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；</li>
<li>会产生内部碎片，内部利用率低。</li>
</ul>
</li>
</ul>
<h4 id="3-1-4-3-动态分区分配">3.1.4.3 动态分区分配</h4>
<ul>
<li>
<p><strong>动态分区分配</strong>又称为<strong>可变分区分配</strong>。这种分配方式<strong>不会预先划分内存分区</strong>，而是在进程装入内存时，<strong>根据进程的大小动态地建立分区</strong>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</p>
</li>
<li>
<p>使用两种数据结构记录内存的使用情况：</p>
<ul>
<li>空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息。</li>
<li>空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息。</li>
</ul>
</li>
<li>
<p>把一个新作业装入内存时，需按照一定的<strong>动态分区分配算法</strong>，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。</p>
</li>
<li>
<p>相邻的空闲分区要合并。</p>
</li>
<li>
<p>动态分区分配<strong>没有内部碎片</strong>，但是<strong>有外部碎片</strong>。</p>
</li>
<li>
<p>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。</p>
</li>
<li>
<p>外部碎片：是指内存中的某些空闲分区由于太小而难以利用。</p>
</li>
<li>
<p>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。</p>
</li>
<li>
<p>可以通过**紧凑（拼凑，Compaction）**技术来解决外部碎片。</p>
</li>
</ul>
<h3 id="3-1-5-动态分区分配算法">3.1.5 动态分区分配算法</h3>
<h4 id="3-1-5-1-首次适应算法">3.1.5.1 首次适应算法</h4>
<ul>
<li>思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</li>
<li>实现：空闲分区以<strong>地址递增</strong>的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li>
<li>缺点：每次都从链头开始查找，这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。</li>
</ul>
<h4 id="3-1-5-2-最佳适应算法">3.1.5.2 最佳适应算法</h4>
<ul>
<li>思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。</li>
<li>实现：空闲分区按<strong>容量递增</strong>次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li>
<li>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</li>
</ul>
<h4 id="3-1-5-3-最坏适应算法">3.1.5.3 最坏适应算法</h4>
<ul>
<li>思想：又称最大适应算法。为了解决最佳适应算法的问题，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</li>
<li>实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li>
<li>缺点：会导致“大进程”没有内存分区使用。</li>
</ul>
<h4 id="3-1-5-4-邻近适应算法">3.1.5.4 邻近适应算法</h4>
<ul>
<li>思想：首次适应算法每次都从链头开始查找，这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，，就能解决上述问题。</li>
<li>实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时<strong>从上次查找结束的位置开始</strong>查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li>
<li>缺点：可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用。</li>
</ul>
<h3 id="3-1-6-基本分页存储管理的基本概念">3.1.6 基本分页存储管理的基本概念</h3>
<ul>
<li>
<p><strong>页框</strong>：将内存空间分为一个个<strong>大小相等的分区</strong>（比如：每个分区 4KB），每个分区就是一个“<strong>页框</strong>”（页框=页帧=内存块=物理块=物理页面）。每个页框有一个编号，即“<strong>页框号</strong>”（页框号=页帧号=内存块号=物理块号=物理页号），页框号<strong>从 0 开始</strong>。</p>
</li>
<li>
<p><strong>页面</strong>：将<strong>进程的逻辑地址空间</strong>也分为<strong>与页框大小相等</strong>的一个个部分，每个部分称为一个“<strong>页</strong>“或”<strong>页面</strong>“。每个页面也有一个编号，即”<strong>页号</strong>“，页号也是<strong>从 0 开始</strong>。</p>
</li>
<li>
<p>操作系统<strong>以页框为单位为各个进程分配</strong>内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的<strong>页面</strong>与内存的<strong>页框</strong>有<strong>一一对应</strong>的关系。</p>
</li>
<li>
<p>各个页面不必连续存放，可以放到不相邻的各个页框中。</p>
</li>
<li>
<p><strong>页表</strong>：为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张<strong>页表</strong>。页表通常存在 PCB 中。</p>
<ul>
<li>一个进程对应一张页表；</li>
<li>进程的每个页面对应一个页表项；</li>
<li>每个<strong>页表项</strong>由”页号“和”块号“组成；</li>
<li>页表记录进程<strong>页面</strong>和实际存放的<strong>内存块</strong>之间的映射关系。</li>
</ul>
</li>
<li>
<p>页面在内存中的起始地址 + 页内偏移量 = 实际的物理地址</p>
</li>
<li>
<p>页号 = 逻辑地址 / 页面长度（向下取整）</p>
</li>
<li>
<p>页内偏移量 = 逻辑地址 % 页面长度</p>
</li>
<li>
<p>页面大小取 2 的整数幂的好处：</p>
<ul>
<li>逻辑地址的拆分更加迅速——如果每个页面大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> B，用二进制数表示逻辑地址，则<strong>末尾 k 位</strong>即为<strong>页内偏移量</strong>，其余部分就是<strong>页号</strong>。因此，如果让<strong>每个页面的大小为 2 的整数幂</strong>，计算机硬件就可以很方便低得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度。</li>
<li>物理地址的计算更加迅速——根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址。</li>
</ul>
</li>
<li>
<p>逻辑地址结构</p>
<ul>
<li>
<p>分页存储管理的逻辑地址结构如下所示：</p>
<p><img src="../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241027204044658.png" alt="image-20241027204044658"></p>
</li>
<li>
<p>地址结构包含两个部分：前一部分为页号，后一部分为业内偏移量 W。在上图所示的例子中，地址长度为 32 位，其中 0~11 位为”页内偏移量“，或称”页内地址“；12~31位为”页号“。</p>
</li>
<li>
<p>如果有 k 位表示页面偏移量，则说明该系统中一个页面的大小是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> 个内存单元；</p>
</li>
<li>
<p>如果有 m 位表示页号，则说明在该系统中，一个进程最多允许有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span></span></span> 个页面。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-1-7-基本地址变换机构">3.1.7 基本地址变换机构</h3>
<ul>
<li>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</li>
<li>通常会在系统中设置一个<strong>页表寄存器</strong>（PTR），存放<strong>页表在内存中的起始地址 F</strong> 和<strong>页表长度 M</strong>。进程未执行时，页表的始址和页表长度<strong>放在进程控制块（PCB）中</strong>，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</li>
<li>注意：<strong>页面大小是 2 的整数幂</strong>。</li>
<li>设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下：
<ol>
<li>计算页号 P 和页内偏移量 W。</li>
<li>比较页号 P 和页表长度 M，若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>≥</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">P\geq M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> ，则产生越界中断，否则继续执行；</li>
<li>页表中页号 P 对应的<strong>页表项地址 = 页表起始地址 F + 页号 P * 页表项长度</strong>，取出该页表项内容 b，即为内存块号。（注意区分<strong>页表项长度、页表长度、页面大小的区别</strong>。<strong>页表长度</strong>指的是这个页表中总共有几个页表项，即总共有几个页；<strong>页表项长度</strong>指的是每个页表项占多大的存储空间；<strong>页面大小</strong>指的是一个页面占多大的存储空间）</li>
<li>计算 E = b * L + W，用得到的物理地址 E 去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）</li>
</ol>
</li>
<li>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，<strong>页式管理中地址是一维的</strong>。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中页面偏移量占多少位。</li>
</ul>
<h3 id="3-1-8-具有快表的地址变换机构">3.1.8 具有快表的地址变换机构</h3>
<ul>
<li><strong>快表</strong>，又称<strong>联想寄存器</strong>（TLB，translation lookaside buffer），是一种<strong>访问速度比内存快很多的</strong>高速缓存，用来存放<strong>最近访问的页表项的副本</strong>，可以加速地址变换的速度。与之对应，内存中的页表项常称为<strong>慢表</strong>。</li>
<li>引入快表后，地址的变换过程：
<ol>
<li>CPU 给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li>
<li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，<strong>访问</strong>该物理地址对应的<strong>内存单元</strong>。因此，若<strong>快表命中</strong>，则访问某个逻辑地址仅需<strong>一次访存</strong>即可。</li>
<li>如果没有找到匹配的页号，则需要<strong>访问内存中的页表</strong>，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，<strong>访问</strong>该物理地址对应的<strong>内存单元</strong>。因此，若<strong>快表未命中</strong>，则访问某个逻辑地址需要<strong>两次访存</strong>（注：<strong>在找到页表项后，应同时将其存入快表</strong>，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</li>
</ol>
</li>
<li>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。</li>
<li>因为局部性原理，一般来说快表的命中率可以达到 90% 以上。</li>
<li>局部性原理：
<ul>
<li><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量循环）</li>
<li><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）</li>
</ul>
</li>
</ul>
<h3 id="3-1-9-两级页表">3.1.9 两级页表</h3>
<ul>
<li>
<p>单级页表的问题：</p>
<ol>
<li>
<p>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</p>
</li>
<li>
<p>没有必要让整个页面常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p>
</li>
</ol>
</li>
<li>
<p>可以使用<strong>两级页表</strong>解决单级页表的<strong>问题一</strong>。</p>
</li>
<li>
<p>原理：可将长长的页表进行分组，是每个内存块刚好可以放入一个分组。另外，要为离散分配的页表再建立一张页表，称为<strong>页目录表</strong>，或称<strong>外层页表</strong>，或称<strong>顶层页表</strong>。</p>
</li>
</ul>
<p><img src="../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241028194105241.png" alt="image-20241028194105241"></p>
<ul>
<li>地址变换：
<ol>
<li>按照地质结构将逻辑地址拆分成三部分；</li>
<li>从 PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置；</li>
<li>根据二级页号查表，找到最终想访问的内存块号；</li>
<li>结合页内偏移量得到物理地址。</li>
</ol>
</li>
<li>注意：
<ol>
<li>若采用多级页表机制，则<strong>各级页表的大小不能超过一个页面</strong>。</li>
<li>两级页表的<strong>访存次数</strong>分析（假设没有快表机构）：
<ol>
<li>第一次访存：访问内存中的页目录表；</li>
<li>第二次访存：访问内存中的二级页表；</li>
<li>第三次访存：访问目标内存单元。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="3-1-10-基本分段存储管理">3.1.10 基本分段存储管理</h3>
<ul>
<li>
<p>进程的地址空间：按照程序<strong>自身的逻辑</strong>关系<strong>划分为若干个段</strong>，每个段都有一个段名，<strong>每段从 0 开始编址</strong>。</p>
</li>
<li>
<p>内存分配规则：以段为单位进行分配，<strong>每个段在内存中占据连续空间</strong>，但<strong>各段之间可以不相邻</strong>。</p>
</li>
<li>
<p>由于是按照逻辑功能模块划分，用户<strong>编程更方便，程序的可读性更高</strong>。</p>
</li>
<li>
<p>分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成。如：</p>
<p><img src="../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241028195557197.png" alt="image-20241028195557197"></p>
<ul>
<li>段号的位数决定了每个进程最多可以分为几个段；</li>
<li>段内地址位数决定了每个段的最大长度是多少。</li>
</ul>
</li>
<li>
<p><strong>段表</strong>：程序分为多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需要为每个进程建立一张段映射表，简称“段表”。</p>
</li>
<li>
<p>每个段对应一个段表项，其中记录了该段在内存中的<strong>起始位置（基址</strong>）和<strong>段的长度</strong>。</p>
</li>
<li>
<p><strong>各个段表项的长度是相同的</strong>。因此<strong>段号可以是隐含的，不占存储空间</strong>。</p>
</li>
<li>
<p>分段、分页管理的对比</p>
<ul>
<li><strong>页</strong>是<strong>信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<strong>对用户是不可见的。</strong></li>
<li><strong>段</strong>是<strong>信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</li>
<li>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</li>
<li><strong>分页</strong>的用户进程<strong>地址空间是一维的</strong>，程序员只需给出一个记忆符即可表示一个地址。</li>
<li><strong>分段</strong>的用户进程<strong>地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</li>
<li><strong>分段</strong>比分页<strong>更容易实现信息的共享和保护</strong>。
<ul>
<li>不能被修改的代码称为<strong>纯代码</strong>或<strong>可重入代码</strong>（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-1-11-段页式管理方式">3.1.11 段页式管理方式</h3>
<ul>
<li>
<p>分页、分段的优缺点分析</p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>分页管理</td>
<td>内存空间利用率极高，<strong>不会产生外部碎片</strong>，只会有少量的业内碎片</td>
<td>不方便按照逻辑模块实现信息的共享和保护</td>
</tr>
<tr>
<td>分段管理</td>
<td>很方便按照逻辑模块实现信息的共享和保护</td>
<td>如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理<strong>会产生外部碎片</strong></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>段页式管理：将进程按逻辑模块分段，再将各段分页，再将内存空间分为大小相同的内存块/页框/页帧/物理块，进程前将各页面分别装入各内存块中。</p>
</li>
<li>
<p>段页式管理的逻辑地址结构：由段号、页号、页内地址（页内偏移量）组成。如：</p>
<p><img src="../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241028202212081.png" alt="image-20241028202212081"></p>
<ul>
<li>段号的位数决定了每个进程最多可以分几个段；</li>
<li>页号位数决定了每个段最大有多少页；</li>
<li>页内偏移量决定了页面大小、内存块大小是多少。</li>
</ul>
</li>
<li>
<p>段页式管理的地址结构是<strong>二维</strong>的。</p>
</li>
<li>
<p>段表、页表</p>
<ul>
<li>每个段对应一个段表项，每个段表项由段号、<strong>页表长度</strong>、<strong>页表存放块号（页表起始地址）<strong>组成。每个</strong>段表项长度相等，段号是隐含的</strong>。</li>
<li>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。</li>
</ul>
</li>
</ul>
<h2 id="3-2-虚拟存储器">3.2 虚拟存储器</h2>
<h3 id="3-2-1-虚拟内存的基本概念">3.2.1 虚拟内存的基本概念</h3>
<ul>
<li>
<p>传统存储管理方式的特征、缺点</p>
<ul>
<li><strong>一次性</strong>：<strong>作业必须一次性全部装入内存后才能开始运行</strong>。这会造成两个问题：
<ol>
<li>作业很大时，不能全部装入内存，导致<strong>大作业无法运行</strong>；</li>
<li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致<strong>多道程序并发度下降</strong>。</li>
</ol>
</li>
<li><strong>驻留性</strong>：一旦作业被装入内存，就<strong>会一直驻留在内存中</strong>，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</li>
</ul>
</li>
<li>
<p>虚拟内存的定义和特征</p>
<ul>
<li>定义：
<ul>
<li>基于局部性原理，在程序装入时，可以将程序中<strong>很快会用到的部分装入内存，暂时用不到的部分留在外存</strong>，就可以让程序开始执行。</li>
<li>在程序执行过程中，当所访问的<strong>信息不在内存时</strong>，由操<strong>作系统负责将所需信息从外存调入内存</strong>，然后继续执行程序。</li>
<li>若内存空间不够，由<strong>操作系统负责</strong>将内存中<strong>暂时用不到的信息换出到外存</strong>。</li>
<li>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong>。</li>
</ul>
</li>
<li>特征：
<ol>
<li><strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li>
<li><strong>对换性</strong>：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li>
<li><strong>虚拟性</strong>：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>虚拟内存技术的实现</p>
</li>
</ul>
<h3 id="3-2-3-页面置换算法">3.2.3 页面置换算法</h3>
<h4 id="3-2-3-1-最佳置换算法-opt">3.2.3.1 最佳置换算法（OPT）</h4>
<ul>
<li>最佳置换算法（OPT，Optimal）：每次选择<strong>淘汰的页面</strong>将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。</li>
<li>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，<strong>最佳置换算法是无法实现的</strong>。</li>
</ul>
<h4 id="3-2-3-2-先进先出置换算法-fifo">3.2.3.2 先进先出置换算法（FIFO）</h4>
<ul>
<li>先进先出置换算法（FIFO）：每次选择<strong>淘汰的页面</strong>是<strong>最早进入内存的页面</strong>。</li>
<li>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少内存块。</li>
<li><strong>Belady 异常</strong>——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</li>
<li><strong>只有 FIFO 算法会产生 Belady 异常</strong>。另外，FIFO 算法虽然<strong>实现简</strong>单，但是该算法与进程实际运行时的规律不适应，因为先进入的也有可能最经常被访问。因此，<strong>算法性能差</strong>。</li>
</ul>
<h4 id="3-2-3-3-最近最久未使用置换算法-lru">3.2.3.3 最近最久未使用置换算法（LRU）</h4>
<ul>
<li>最近最久未使用置换算法（LRU，least recently used）：每次淘汰的页面是最近最久未使用的页面。</li>
<li>实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间 t。当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。</li>
<li>该算法的实现需要专门的硬件支持，虽然算法<strong>性能好</strong>，但是<strong>实现困难</strong>，<strong>开销大</strong>。</li>
</ul>
<h4 id="3-2-3-4-时钟置换算法-clock">3.2.3.4 时钟置换算法（CLOCK）</h4>
<ul>
<li>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近 OPT 算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</li>
<li><strong>时钟置换算法</strong>是一种性能与开销较均衡的算法，又称 <strong>CLOCK 算法</strong>，或<strong>最近未用算法</strong>（<strong>NRU</strong>，Not Recently Used）。</li>
<li><strong>简单的 CLOCK 算法</strong>实现方法：为每个页面设置一个<strong>访问位</strong>，再将内存中的页面都通过链接指针<strong>链接成一个循环队列</strong>。当某页被访问时，其访问位置为 1。当需要淘汰一个页面时，只需检查页的访问位。如果是 0，就选择该页换出；如果是 1，则将它置为 0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描（第二轮扫描中一定会有访问位为 0  的页面，因此<strong>简单的 CLOCK 算法</strong>选择一个淘汰页面<strong>最多会经过两轮扫描</strong>）。</li>
</ul>
<h4 id="3-2-3-5-改进型的时钟置换算法">3.2.3.5 改进型的时钟置换算法</h4>
<ul>
<li><strong>简单的时钟置换算法</strong>仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行 I/O 操作写回外存。<strong>只有被淘汰的页面被修改过时，才需要写回外存</strong>。</li>
<li>因此除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。<strong>在其他条件都相同时，应优先淘汰没有修改过的页面</strong>，避免 I/O 操作。这就是改进型的时钟置换算法的思想。</li>
<li><strong>修改位 = 0</strong>，表示页面没有被修改过；<strong>修改位 = 1</strong>，表示页面被修改过。</li>
<li>为方便讨论，用**（访问位，修改位）**的形式表示各页面状态。如（1， 1）表示一个页面近期被访问过，且被修改过。</li>
<li><strong>算法规则</strong>：将所有可能被置换的页面排成一个循环队列。
<ol>
<li>第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位。</li>
<li>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的的帧访问位设为 0.</li>
<li>第三轮：若第二轮扫描失败，则重新扫锚，查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位。</li>
<li>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。</li>
</ol>
</li>
<li>由于第二轮已将所有的帧的访问位设为 0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此<strong>改进型 CLOCK 置换算法</strong>选择一个淘汰页面<strong>最多会进行四轮扫描</strong>。</li>
</ul>
<h1 id="第四章-文件管理">第四章 文件管理</h1>
<h2 id="4-1-初识文件管理">4.1 初识文件管理</h2>
<ul>
<li>文件的属性
<ul>
<li><strong>文件名</strong>：由创建文件的用户决定文件名，主要是为了方便用户找到文件，<strong>同一目录下不允许有重名文件</strong>。</li>
<li><strong>标识符</strong>：一个系统内的个文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</li>
<li><strong>类型</strong>：指明文件的类型。</li>
<li><strong>位置</strong>：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）。</li>
<li><strong>创建时间、上次修改时间、文件所有者信息</strong>。</li>
<li><strong>保护信息</strong>：对文件进行保护的访问控制信息。</li>
</ul>
</li>
<li>文件的分类
<ul>
<li>无结构文件：由一系列二进制或字符流组成。</li>
<li>有结构文件：如表格。</li>
</ul>
</li>
<li>操作系统通过<strong>目录</strong>组织各个文件。</li>
<li>操作系统应向上提供的功能：create, delete, open, close, read, write 系统调用。</li>
</ul>
<h2 id="4-2-文件的逻辑结构">4.2 文件的逻辑结构</h2>
<h3 id="4-2-1无结构文件">4.2.1无结构文件</h3>
<ul>
<li>文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。如：Windows操作系统中的 .txt 文件。</li>
</ul>
<h3 id="4-2-2-有结构文件">4.2.2 有结构文件</h3>
<ul>
<li>由一组相似的记录组成，又称“记录式文件”。每条记录由若干个数据项组成。如：数据库表文件。一般来说，每条记录有一个数据项可作为关键字。根据各类记录的长度（占用的存储空间）是否相等，又可分为定长记录和可变长记录两种。</li>
</ul>
<h4 id="4-2-2-1-顺序文件">4.2.2.1 顺序文件</h4>
<ul>
<li>
<p>文件中的记录一个接一个的顺序排列（逻辑上），记录可以是<strong>定长</strong>的或<strong>可变长</strong>的。各个记录在物理上可以<strong>顺序存储</strong>或<strong>链式存储</strong>。</p>
</li>
<li>
<p>串结构：记录之间的顺序与关键字无关。</p>
</li>
<li>
<p>顺序结构：记录之间的顺序按关键字顺序排列。</p>
</li>
<li>
<p>特点：</p>
<ul>
<li><strong>链式存储</strong>：无论是定长/可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找。</li>
<li><strong>顺序存储</strong>：
<ul>
<li><strong>可变长记录</strong>：无法实现随机存取。每次只能从第一个记录开始依次往后查找。</li>
<li><strong>定长记录</strong>：可实现随机存取。记录长度为 L，则第 i 个记录存放的相对位置是 i*L。
<ul>
<li>若采用串结构，无法快速找到某关键字对应的记录。</li>
<li>若采用顺序结构，可以快速找到某关键字对应的记录（如折半查找）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>顺序文件的<strong>缺点</strong>是<strong>增加/删除一个记录比较困难</strong>（如果是串结构则相对简单）。</p>
</li>
</ul>
<h4 id="4-2-2-2-索引文件">4.2.2.2 索引文件</h4>
<ul>
<li>建立一张索引表以加快文件检索速度。每条记录对应一个索引项。文件中的这些记录在物理上可以离散的存放。<strong>索引表</strong>本身是<strong>定长记录的顺序文件</strong>。因此可以快速找到第 i 个记录对应的索引项。由于索引文件有很快的检索速度，因此<strong>主要用于对信息处理的及时性要求比较高的场合</strong>。</li>
</ul>
<h4 id="4-2-2-3-索引顺序文件">4.2.2.3 索引顺序文件</h4>
<ul>
<li>索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是，并不是每个记录对应一个索引表项，而是<strong>一组记录对应一个索引表项</strong>。</li>
</ul>
<h4 id="4-2-2-4-多级索引顺序文件">4.2.2.4 多级索引顺序文件</h4>
<ul>
<li>为了进一步提高检索效率，可以为顺序文件<strong>建立多级索引表</strong>。</li>
</ul>
<h2 id="4-3-文件目录">4.3 文件目录</h2>
<h3 id="4-3-1-文件控制块">4.3.1 文件控制块</h3>
<ul>
<li>文件控制块 FCB 的有序集合称为“文件目录”，一个 FCB 就是一个文件<strong>目录项</strong>。</li>
<li>FCB 中包含了文件的<strong>基本信息</strong>（<strong>文件名</strong>、<strong>物理地址</strong>、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。<strong>最重要、最基本</strong>的还是<strong>文件名、文件存放的物理地址</strong>。</li>
<li>FCB 实现了文件名和文件之间的映射。使用户可以实现“按名存取”。</li>
<li>需要对目录进行的操作：搜索、创建文件、删除文件、显示目录、修改目录。</li>
</ul>
<h3 id="4-3-2-目录结构">4.3.2 目录结构</h3>
<ul>
<li>单级目录结构：早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。
<ul>
<li>单级目录实现了“按名存取”，但是<strong>不允许文件重名</strong>。</li>
<li>在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。</li>
</ul>
</li>
<li>两级目录结构：早期的多用户操作系统，采用两级目录结构。分为<strong>主文件目录</strong>（MFD, Master File Directory）和<strong>用户文件目录</strong>（UFD, User File Directory）。
<ul>
<li><strong>允许不同用户的文件重名</strong>。文件名虽然相同，但是对应的其实是不同的文件。</li>
<li>缺乏灵活性，用户不能对自己的文件进行分类。</li>
</ul>
</li>
<li>多级目录结构（树型目录结构）
<ul>
<li>用户要访问某个文件时要用文件路径名称标识文件，文件路径名是个字符串。各级目录之间用“/”隔开。从根目录出发的路径称为<strong>绝对路径</strong>。</li>
<li>很多时候，用户会连续访问同一目录内的多个文件，显然，每次都从根目录开始查找，是很低效的。因此可以设置一个“<strong>当前目录</strong>”。当用户想要访问某个文件时，可以使用<strong>从当前目录出发</strong>的“<strong>相对路径</strong>”。</li>
<li><strong>树形目录结构</strong>可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构<strong>不便于实现文件的共享</strong>。为此，提出了“<strong>无环图目录结构</strong>”。</li>
</ul>
</li>
<li>无环图目录结构：在树型目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个<strong>有向无环图</strong>。可以更方便地实现多个用户间的文件共享。
<ul>
<li><strong>可以用不同的文件名指向同一个文件</strong>，甚至可以指向同一个目录（共享同一目录下的所有内容）。</li>
<li>需要为<strong>每个共享节点设置一个共享计数器</strong>，用于记录此时有多少个地方在共享该节点。用户提出删除节点的请求时，只是删除该用户的 FCB 并使<strong>共享计数器减 1</strong>，并不会直接删除共享节点。<strong>只有共享计数器减为 0 时，才删除节点</strong>。</li>
</ul>
</li>
</ul>
<h3 id="4-3-3-索引节点">4.3.3 索引节点</h3>
<ul>
<li>其实在查找各级目录的过程中只需要用到“文件名”这个信息，只有文件名匹配时，才需要读出文件的其他信息。因此可以考虑让目录表“瘦身”来提升效率。</li>
<li>将 FCB 中除了文件名之外的文件描述信息都放到索引节点中，文件目录中只存放文件名和对应的索引节点指针。</li>
<li>当找到文件名对应的目录项时，才需要将索引节点调入内存，索引节点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</li>
<li>存放<strong>在外存中</strong>的索引节点称为“<strong>磁盘索引节点</strong>”，当索引节点<strong>放入内存</strong>后称为“<strong>内存索引节点</strong>”。相比之下<strong>内存索引节点中需要增加一些信息</strong>，比如：文件是否被修改、此时有几个进程正在访问该文件等。</li>
</ul>
<h2 id="4-4-文件的物理结构">4.4 文件的物理结构</h2>
<h3 id="4-4-1-连续分配">4.4.1 连续分配</h3>
<ul>
<li>
<p><strong>连续分配</strong>方式要求<strong>每个文件在磁盘上占有一组连续的块</strong>。</p>
</li>
<li>
<p>文件目录中记录存放起始块号和长度（总共占用几个块）。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>物理块号</mtext><mo>=</mo><mtext>起始块号</mtext><mo>+</mo><mtext>逻辑块号</mtext></mrow><annotation encoding="application/x-tex">物理块号=起始块号+逻辑块号
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">物</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">号</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">起</span><span class="mord cjk_fallback">始</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">号</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">逻</span><span class="mord cjk_fallback">辑</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">号</span></span></span></span></span></p>
</li>
<li>
<p>还需要检查用户提供的逻辑块号是否合法（逻辑块号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span> 长度就不合法）。</p>
</li>
<li>
<p>优点：</p>
<ol>
<li><strong>顺序读/写时速度最快</strong>。</li>
<li><strong>支持顺序访问和直接访问（随机访问）</strong>。</li>
</ol>
</li>
<li>
<p>缺点：</p>
<ol>
<li>文件<strong>不方便拓</strong>展。</li>
<li><strong>存储空间利用率低，会产生难以利用的磁盘碎片</strong>。可以用<strong>紧凑</strong>来处理碎片，但是需要耗费很大的时间代价。</li>
</ol>
</li>
</ul>
<h3 id="4-4-2-链接分配">4.4.2 链接分配</h3>
<ul>
<li><strong>链接分</strong>配采取离散分配的方式，可以为文件分配离散的磁盘块。分为<strong>隐式链接</strong>和<strong>显式链接</strong>两种。</li>
</ul>
<h4 id="4-4-2-1-隐式链接">4.4.2.1 隐式链接</h4>
<ul>
<li>目录中记录了文件存放的起始块号和结束块号。当然，也可以增加一个字段来表示文件的长度。</li>
<li>除了文件的最后一个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户是透明的。</li>
<li>读入 i 号逻辑块，总共需要 i+1 次磁盘调用。</li>
<li>结论：
<ul>
<li><strong>只支持顺序访问，不支持随机访问</strong>，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。</li>
<li><strong>方便文件拓展，不会有碎片问题，外存利用率高</strong>。</li>
</ul>
</li>
</ul>
<h4 id="4-4-2-2-显式链接">4.4.2.2 显式链接</h4>
<ul>
<li>把用于链接文件各物理块的指针显示地存放在一张表中，即文件分配表（FAT，File Allocation Table）。</li>
<li>目录中只需记录文件的起始块号。</li>
<li>注意：<strong>一个磁盘仅设置一张 FAT</strong>。开机时，将 FAT 读入内存，并常驻内存。FAT 的各个表项在物理上连续存储，且每个表项长度相同，因此“物理块号”字段可以是隐含的。</li>
<li>从目录项中找到起始块号，若 i &gt; 0，则查询内存中的文件分配表 FAT，往后找到 i 号逻辑块对应的物理块号。<strong>逻辑块号转换成物理块号的过程不需要读磁盘操作</strong>。</li>
<li>结论：
<ul>
<li><strong>支持顺序访问，也支持随机访问</strong>，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</li>
<li><strong>不会产生外部碎片，也可以很方便地对文件进行拓展</strong>。</li>
<li>文件分配表需要占用一定的存储空间。</li>
</ul>
</li>
</ul>
<h3 id="4-4-3-索引分配">4.4.3 索引分配</h3>
<ul>
<li><strong>索引分配</strong>允许文件离散地分配在各个磁盘块中，系统会<strong>为每个文件建立一张索引表</strong>，索引表中<strong>记录了文件的各个逻辑块对应的物理块</strong>。索引表存放的磁盘块称为<strong>索引块</strong>。文件数据存放的磁盘块称为<strong>数据块</strong>。</li>
<li>注：在显式链接的链式分配方式中，文件分配表 FAT 是一个磁盘对应一张。而索引分配方式中，索引表是一个文件对应一张。</li>
<li>可以用固定的长度表示物理块号，因此，索引表中的“逻辑块号”可以是隐含的。</li>
<li>结论：
<ul>
<li>支持随机访问。</li>
<li>文件拓展容易实现。</li>
<li>索引表需要占用一定的存储空间。</li>
</ul>
</li>
<li>索引分配方案：
<ol>
<li><strong>链接方案</strong>：将多个索引块链接起来存放。
<ul>
<li>缺点：查找效率低下。</li>
</ul>
</li>
<li><strong>多层索引</strong>：建立多层索引（原理类似于<strong>多级页表</strong>）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。
<ul>
<li>若采用多层索引，则<strong>各层索引表大小不能超过一个磁盘块</strong>。</li>
<li>采用 k 层索引结构，且<strong>顶层索引表未调入内存</strong>，则访问一个数据块只需要 k + 1 次读磁盘操作。</li>
<li>缺点：即使是小文件，访问一个数据块依然需要 k + 1 次读磁盘。</li>
</ul>
</li>
<li><strong>混合索引</strong>：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<strong>直接地址索引</strong>（直接指向<strong>数据块</strong>），又包含<strong>一级间接索引</strong>（指向单层索引表）、还包含<strong>两级间接索引</strong>（指向两层索引表）。
<ul>
<li>优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="4-5-文件存储空间管理">4.5 文件存储空间管理</h2>
<h3 id="4-5-1-存储空间的划分与初始化">4.5.1 存储空间的划分与初始化</h3>
<ul>
<li>存储空间的划分：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）。</li>
<li>存储空间的初始化：将各个文件卷划分为目录区、文件区。
<ul>
<li>目录区：主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息。</li>
<li>文件区：用于存放文件数据。</li>
</ul>
</li>
</ul>
<h3 id="4-5-2-存储空间管理">4.5.2 存储空间管理</h3>
<h4 id="4-5-2-1-空闲表法">4.5.2.1 空闲表法</h4>
<p><img src="../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241122193608061.png" alt="image-20241122193608061"></p>
<ul>
<li>适用于“连续分配管理”。</li>
<li>如何分配磁盘块：与内存管理中的动态分区分配类似，为一个文件<strong>分配连续的存储空间</strong>，同样<strong>可采用首次适应、最佳适应、最坏适应</strong>等算法来决定要为文件分配哪个区间。</li>
<li>如何回收磁盘块：与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况——回收区的前后都没有相邻空闲区；回收区的前后都是空闲区；回收区前面是空闲区；回收区后面是空闲区。总之，<strong>回收时需要注意表项的合并问题。</strong></li>
</ul>
<h4 id="4-5-2-2-空闲链表法">4.5.2.2 空闲链表法</h4>
<ul>
<li>空闲盘块链——以盘块为单位组成一条空闲链，空闲盘块中存储着下一个空闲盘块的指针；
<ul>
<li>操作系统保存着<strong>链头、链尾指针</strong>。</li>
<li>分配：若某文件申请 k 个盘块，则从链头开始依次摘下 k 个盘块分配，并修改空闲链的链头指针；</li>
<li>回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</li>
<li>特点：适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作。</li>
</ul>
</li>
<li>空闲盘区链——以盘区（连续的空闲盘块组成一个空闲盘区）为单位组成一条空闲链，空闲盘区中的第一个盘块内记录了盘区的长度、下一个盘区的指针。
<ul>
<li>操作系统保存着<strong>链头、链尾指针</strong>。</li>
<li>分配：若某文件申请 k 个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</li>
<li>回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</li>
<li>特点：离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高。</li>
</ul>
</li>
</ul>
<h4 id="4-5-2-3-位示图法">4.5.2.3 位示图法</h4>
<p><img src="../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241122200128377.png" alt="image-20241122200128377"></p>
<ul>
<li>特点：连续分配、离散分配都适用。</li>
</ul>
<h4 id="4-5-2-4-成组链接法">4.5.2.4 成组链接法</h4>
<ul>
<li>UNIX 采用的策略，适合大型文件系统。理解即可。</li>
</ul>
<h2 id="4-6-文件的基本操作">4.6 文件的基本操作</h2>
<h3 id="4-6-1-创建文件">4.6.1 创建文件</h3>
<ul>
<li>进行 Create 系统调用时，需要提供的几个主要参数：
<ol>
<li>所需的外存空间大小</li>
<li>文件存放路径</li>
<li>文件名</li>
</ol>
</li>
<li>操作系统在处理 Create 系统调用时，主要做了两件事：
<ol>
<li><strong>在外存中找到文件所需的空间</strong>（结合管理策略找到空闲空间）</li>
<li>根据文件存放路径的信息找到该目录对应的目录文件，在目录中<strong>创建该文件对应的目录项</strong>。目录项中包含了文件名、文件在外存中的存放位置等信息。</li>
</ol>
</li>
</ul>
<h3 id="4-6-2-删除文件">4.6.2 删除文件</h3>
<ul>
<li>进行 Delete 系统调用时，需要提供的几个主要参数：
<ol>
<li>文件存放路径</li>
<li>文件名</li>
</ol>
</li>
<li>操作系统在处理 Delete 系统调用时，主要做了几件事：
<ol>
<li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的目录项</strong>。</li>
<li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong>。</li>
<li>从目录表中<strong>删除文件的目录项</strong>。</li>
</ol>
</li>
</ul>
<h3 id="4-6-3-打开文件">4.6.3 打开文件</h3>
<ul>
<li>在很多操作系统中，在对文件进行操作之前，要求用户先使用 open 系统调用“打开文件”，需要提供的几个主要参数：
<ol>
<li>文件存放路径</li>
<li>文件名</li>
<li>要对文件的操作类型（如：r 只读；rw 读写等）</li>
</ol>
</li>
<li>操作系统在处理 open 系统调用时，主要做了几件事：
<ol>
<li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的目录项</strong>，并检查该用户是否有指定的操作权限。</li>
<li><strong>将目录项复制到内存中的“打开文件表”中</strong>，并将对应表目的编号返回给用户。之后<strong>用户使用打开文件表的编号来指明要操作的文件</strong>。</li>
</ol>
</li>
</ul>
<p><img src="../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241122210539362.png" alt="image-20241122210539362"></p>
<h3 id="4-6-4-关闭文件">4.6.4 关闭文件</h3>
<ul>
<li>进程使用完文件后，要“关闭文件”。</li>
<li>操作系统在处理 close 系统调用时，主要做了几件事：
<ol>
<li>将进程的打开文件表相应表项删除</li>
<li>回收分配给该文件的内存空间等资源</li>
<li>系统打开文件表的打开计数器 count 减 1，若 count = 0，则删除对应表项。</li>
</ol>
</li>
</ul>
<h3 id="4-6-5-读文件">4.6.5 读文件</h3>
<ul>
<li>进程使用 read 系统调用完成读操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要读入多少数据、读入的数据要放在内存中的什么位置。</li>
<li>操作系统在处理 read 系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</li>
</ul>
<h3 id="4-6-6-写文件">4.6.6 写文件</h3>
<ul>
<li>进程使用 write 系统调用完成写操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要写出多少数据、写回外存的数据放在内存中的什么位置。</li>
<li>操作系统在处理 write 系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</li>
</ul>
<h2 id="4-7-文件共享">4.7 文件共享</h2>
<ul>
<li>基于索引节点的共享方式（硬链接）
<ul>
<li>各个用户的目录项指向同一个索引节点</li>
<li>索引节点中需要有链接计数 count</li>
<li>某用户想删除文件时，只是删除该用户的目录项，且 count–</li>
<li>只有 count == 0 时才能真正删除文件数据和索引节点，否则会导致指针悬空</li>
</ul>
</li>
<li>基于符号链的共享方式（软链接）
<ul>
<li>在一个 Link 型的文件中记录共享文件的存放路径（ Windows 快捷方式）</li>
<li>操作系统根据路径一层层查找目录，最终找到共享文件</li>
<li>即使软链接指向的共享文件已被删除，Link 型文件依然存在，只是通过 Link 型文件中的路径去查找共享文件会失败（找不到对应目录项）</li>
<li>由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘 I/O，因此用软链接访问效率较低</li>
</ul>
</li>
</ul>
<h2 id="4-8-文件保护">4.8 文件保护</h2>
<ul>
<li><strong>口令保护</strong>：为文件设置一个口令，用户请求访问该文件时必须提供“口令”。
<ul>
<li>口令一般保存在文件对应的 FCB 或索引节点中。</li>
<li>优点：保存口令的空间开销不多，验证口令的时间开销也很小。</li>
<li>缺点：正确的“口令”存放在系统内部，不够安全。</li>
</ul>
</li>
<li><strong>加密保护</strong>：使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。
<ul>
<li>优点：保密性强，不需要在系统中存储“密码”。</li>
<li>缺点：编码/译码要花费一定时间。</li>
</ul>
</li>
<li><strong>访问控制</strong>：在每个文件的 FCB（或索引节点）中增加一个<strong>访问控制列表</strong>（Access-Control List，ASL），该表中记录了各个用户可以对该文件执行哪些操作。
<ul>
<li>精简的访问列表：以“组”为单位，标记各组用户可以对文件执行哪些操作。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://RainyDoor.github.io">RainyDoor</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://rainydoor.github.io/71959014.html">https://rainydoor.github.io/71959014.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://RainyDoor.github.io" target="_blank">RainyDoor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="/img/109310857_p0.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/1a94f78a.html" title="网络编程学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">网络编程学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/712a89d6.html" title="Java 多线程学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java 多线程学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/109310857_p0.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">RainyDoor</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/RainyDoor" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3391182076@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-text">第一章 操作系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5-%E5%8A%9F%E8%83%BD%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-text">1.1 操作系统的概念、功能和特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-text">1.2 操作系统的发展和分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">1.3 操作系统的运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">1.4 操作系统体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC"><span class="toc-text">1.5 操作系统的引导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-text">1.6 虚拟机</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86"><span class="toc-text">第二章 处理机管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">2.1 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5-%E7%BB%84%E6%88%90-%E7%89%B9%E5%BE%81"><span class="toc-text">2.1.1 进程的概念、组成、特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-text">2.1.2 进程的状态与转换、进程的组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">2.1.3 进程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">2.1.4 进程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">2.1.5 线程的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.1.6 线程的实现方式和多线程模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-text">2.2 处理机的调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5-%E5%B1%82%E6%AC%A1"><span class="toc-text">2.2.1 调度的概念、层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA-%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B-%E6%96%B9%E5%BC%8F"><span class="toc-text">2.2.2 进程调度的时机、切换与过程、方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-1-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-text">2.2.2.1 进程调度的时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-2-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">2.2.2.2 进程调度的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-text">2.2.3 调度算法的评价指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">2.2.4 调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-fcfs-first-come-first-serve"><span class="toc-text">2.2.4.1 先来先服务（FCFS，First Come First Serve）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-2-%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-sjf-shortest-job-first"><span class="toc-text">2.2.4.2 短作业优先（SJF，Shortest Job First）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-3-%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88-hrrn-highest-response-ratio-next"><span class="toc-text">2.2.4.3 高响应比优先（HRRN，Highest Response Ratio Next）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-4-%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-rr-round-robin"><span class="toc-text">2.2.4.4 时间片轮转调度算法（RR，Round-Robin）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-5-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">2.2.4.5 优先级调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-6-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">2.2.4.6 多级反馈队列调度算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-text">2.3 进程的同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-text">2.3.1 进程同步、进程互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.2 进程互斥的软件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-1-%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95"><span class="toc-text">2.3.2.1 单标志法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-2-%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="toc-text">2.3.2.2 双标志先检查法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-3-%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="toc-text">2.3.2.3 双标志后检查法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-4-peterson-%E7%AE%97%E6%B3%95"><span class="toc-text">2.3.2.4 Peterson 算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.3 进程互斥的硬件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-1-%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.3.1 中断屏蔽方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-2-testandset-%E6%8C%87%E4%BB%A4"><span class="toc-text">2.3.3.2 TestAndSet 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-3-swap-%E6%8C%87%E4%BB%A4"><span class="toc-text">2.3.3.3 Swap 指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">2.3.4 互斥锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">第三章 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-text">3.1 存储器管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">3.1.1 内存的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1.2 内存管理的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-text">3.1.3 覆盖与交换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-1-%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="toc-text">3.1.3.1 覆盖技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-2-%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-text">3.1.3.2 交换技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">3.1.4 连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-1-%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-text">3.1.4.1 单一连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-2-%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-text">3.1.4.2 固定分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-3-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-text">3.1.4.3 动态分区分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">3.1.5 动态分区分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-1-%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-text">3.1.5.1 首次适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-2-%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-text">3.1.5.2 最佳适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-3-%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-text">3.1.5.3 最坏适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-4-%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-text">3.1.5.4 邻近适应算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-6-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1.6 基本分页存储管理的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-7-%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">3.1.7 基本地址变换机构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-8-%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">3.1.8 具有快表的地址变换机构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-9-%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-text">3.1.9 两级页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-10-%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-text">3.1.10 基本分段存储管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-11-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">3.1.11 段页式管理方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text">3.2 虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.2.1 虚拟内存的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">3.2.3 页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-1-%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-opt"><span class="toc-text">3.2.3.1 最佳置换算法（OPT）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-2-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-fifo"><span class="toc-text">3.2.3.2 先进先出置换算法（FIFO）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-3-%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-lru"><span class="toc-text">3.2.3.3 最近最久未使用置换算法（LRU）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-4-%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-clock"><span class="toc-text">3.2.3.4 时钟置换算法（CLOCK）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-5-%E6%94%B9%E8%BF%9B%E5%9E%8B%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">3.2.3.5 改进型的时钟置换算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">第四章 文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%88%9D%E8%AF%86%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">4.1 初识文件管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-text">4.2 文件的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1%E6%97%A0%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6"><span class="toc-text">4.2.1无结构文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E6%9C%89%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6"><span class="toc-text">4.2.2 有结构文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-1-%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-text">4.2.2.1 顺序文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-2-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-text">4.2.2.2 索引文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-3-%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-text">4.2.2.3 索引顺序文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-4-%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-text">4.2.2.4 多级索引顺序文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-text">4.3 文件目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-text">4.3.1 文件控制块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">4.3.2 目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="toc-text">4.3.3 索引节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-text">4.4 文件的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-text">4.4.1 连续分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D"><span class="toc-text">4.4.2 链接分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-1-%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5"><span class="toc-text">4.4.2.1 隐式链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-2-%E6%98%BE%E5%BC%8F%E9%93%BE%E6%8E%A5"><span class="toc-text">4.4.2.2 显式链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="toc-text">4.4.3 索引分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-text">4.5 文件存储空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%92%E5%88%86%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">4.5.1 存储空间的划分与初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-text">4.5.2 存储空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-1-%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95"><span class="toc-text">4.5.2.1 空闲表法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-2-%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-text">4.5.2.2 空闲链表法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-3-%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%B3%95"><span class="toc-text">4.5.2.3 位示图法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-4-%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-text">4.5.2.4 成组链接法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">4.6 文件的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-text">4.6.1 创建文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-text">4.6.2 删除文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-3-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-text">4.6.3 打开文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-4-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-text">4.6.4 关闭文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-5-%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-text">4.6.5 读文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-6-%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-text">4.6.6 写文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-text">4.7 文件共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-text">4.8 文件保护</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2b6ffdc0.html" title="spring事务管理">spring事务管理</a><time datetime="2024-12-03T12:00:42.000Z" title="发表于 2024-12-03 20:00:42">2024-12-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/5a028c5b.html" title="Vue2学习笔记">Vue2学习笔记</a><time datetime="2024-10-15T05:19:35.000Z" title="发表于 2024-10-15 13:19:35">2024-10-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2fa71203.html" title="全局异常处理器">全局异常处理器</a><time datetime="2024-10-14T12:34:08.000Z" title="发表于 2024-10-14 20:34:08">2024-10-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/8eda3648.html" title="Redis学习笔记">Redis学习笔记</a><time datetime="2024-10-07T06:51:55.000Z" title="发表于 2024-10-07 14:51:55">2024-10-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/400ea470.html" title="登录校验">登录校验</a><time datetime="2024-10-07T05:52:15.000Z" title="发表于 2024-10-07 13:52:15">2024-10-07</time></div></div></div></div></div></div></main><footer id="footer" style="background: lightgray"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By RainyDoor</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>